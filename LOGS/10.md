今天是 2026 年 1 月 12 日，周一，早上。

今天早起，回想昨天与 C1 讨论的 AI Agent 设计问题，觉得有些启发，需要记录下。

参考 [前情提要](../INSIGHTS/1.md)，我设计了一个模块级人机协同的软件工程架构。

我在考虑如何实现它。

简单来说，关键点在于：

1. 需要通过 `git worktree` 命令，管理代码库，并且给定每个 Repo 的 setup 脚本。
2. 需要通过 CLI 调用 AI Agent (Claude Code, OpenCode, ...etc)，传入 prompt，开启会话 (Session)。
3. 需要能拿到 AI Agent 的结束通知。
4. 需要能拿到 AI Agent 的中间的对话历史，否则无法达成透明性。参考 [这篇文档](../INSIGHTS/2.md) 中提到的可控信任问题，我们需要事中透明性可控性。

基于这些能力，我可以实现一个自动化的脚本，来完成模块级的软件工程任务。

以 Claude Code 为例，

1. Claude Code 可以通过 CLI 直接传入 prompt，开启一个新的会话。
2. Claude Code 可以通过 `-p` 参数，输出结果到 stdout 中时即标识结束。
3. Claude Code 提供了传入 session ID 的能力，然后可以去 `.claude` 目录下找到对应的对话历史文件，从而获得历史消息。

既如此，我就可以写一个脚本，来管理这些工作。

每个 Session 都是独立的，干净的，每个 Session 都会被分配给一个 Agent 来完成。

一个 Agent 实例可以被抽象为一个接口，而无所谓它底层是 Claude Code 还是别的。

而调度器则会根据我们预定的工作流程，调度不同的 Agent 来完成任务。

为什么要基于 Agent 而不是 LLM API？因为 Agent 帮我们处理了底层探索代码库、调用操作系统命令、上下文管理和适配 LLM API 的逻辑，这是一个复杂的系统，我认为我们不需要重复造轮子，除非它不满足要求。

我打算先实现一个最简化的版本，来验证这个思路是否可行，请期待后续的进展记录。
