---
"title": "全スペクトル分析法：情報の最適な収益化手法"
"summary": "本稿では、ケリー基準に基づいて最適化された投資取引戦略フレームワークである全スペクトル分析法（FSA）を提案します。まず、従来のケリー公式が投資応用において持つ限界（レバレッジや空売りの考慮不足、清算タイミングの問題など）を分析します。次に、FSAは結果空間の定義、最適レバレッジと複利収益率の計算を通じて、体系的な取引意思決定モデルを構築します。本稿では、期待収益率と複利収益率の計算、ニュートン法を用いた最適レバレッジ求解アルゴリズムなど、FSAの数学的原理を詳細に説明します。さらに、歴史的バックテスト手法（粗利益率GPMの計算など）、実取引モジュールの考慮事項、ブラックスワン事象への対応策についても紹介します。FSAの中核的な利点は、不完全な確率情報を活用し、レバレッジ意思決定を最適化することで長期的な収益を最大化し、情報の質に対する高い要求を低減できる点にあります。"
"tags":
  - "全スペクトル分析法"
  - "ケリー公式"
  - "投資戦略"
  - "レバレッジ最適化"
  - "複利収益率"
  - "リスク管理"
  - "アルゴリズム取引"
  - "ブラックスワン事象"
"date": "2025-08-10"
---

# 全スペクトル分析法：情報の最適な収益化手法

2025-08-10

## 背景

**資産の成長率を最大化するには？**

1956年、J.L. Kellyは『A New Interpretation of Information Rate』（情報率の新たな解釈）を発表しました。この論文は、既知の情報を利用して資産の複利成長率を最大化する方法について論じています。これは、ギャンブルの賭け方戦略を確率的に導く方法を提案しています。しかし、この論文を実際の投資活動に適用するには、いくつかの問題があります：

1.  借入レバレッジや空売りを考慮しておらず、論文の結論は0〜1の実質レバレッジ範囲に留まっています。
2.  ギャンブラーが賭けるのはある事象記号であり、次にそれが発生すれば配当を得るが、そうでなければ賭け金を失うと仮定しています。しかし、トレーダーは買い/売りにしか賭けることができず、買いと売りに対応する上昇・下落事象は、異なる時間枠において異なる結果と異なる収益率を示します。
3.  清算タイミング：ケリーはギャンブルの終了・清算がギャンブラーの意志で決まらないと仮定しています。しかし、トレーダーはいつでもポジションを解消するか継続するかを決定できます。
4.  冗長なベイズ的手法は、事象の展開が事前確率と条件付き確率に関連すると仮定しています。ベイズ的手法を除去しても導出される数学的本質には影響せず、直接的に論文の公式を使用する難易度を高めています。実際の使用には簡略化が必要です。

我々は、ケリー論文の確率的手法を踏襲し、投資取引分野に適用可能な実用的な戦略を探求します。

## 全スペクトル分析法：Full-Spectrum Analysis, FSA

### 結果空間、最適レバレッジ、最適収益率

ある取引戦略を実行した場合、最終的にはいくつかの異なる結果事象が生じると仮定し、結果空間を $X$ とします。$X$ は空ではありません（実際のシナリオでは少なくとも2つの結果が存在します）。

追加の仮定：

1.  確定的収益：各結果事象は明確な収益率に対応します。結果 $i$ の収益率を $R_i$ とします。
    1.  ✅ 異なる収益率の事象は、異なる結果事象として扱うべきです。例えば、1%の利益と2%の利益は異なります。
    1.  ❌ 明らかに収益率が異なる利益事象を同じ結果にまとめることは、確定的収益の仮定に反します。
1.  確定的確率：結果 $i \in X$ が発生する確率を $P_i$ とします（$0 \le P_i \le 1$）。
    1.  ✅ 各結果の確率は確定的に評価される必要があります。
    1.  ❌ ある結果が発生する可能性が8割以上（80%〜100%）であると考えることは、確定的確率の仮定に反します。
1.  排反性：2つの結果が同時に発生することは不可能です。
    1.  ✅ 絶対に同時に発生しない結果事象を設計する必要があります。
    1.  ❌ 結果事象に共通部分が存在する場合（例：「20分間ポジションを保有する」と「20%下落する」事象が同時に発生する可能性がある）、排反性に反します。
1.  完全性：すべての結果が発生する確率の合計は100%であり、事前に定義された結果以外の結果は存在しません。つまり、$\sum_{i \in X} P_i = 1$ です。
    1.  ✅ 発生する可能性のあるすべての結果を考慮する必要があります。
    1.  ❌ 結果事象として「20%以上上昇」、「20%以上下落」のみを定義し、「-20%〜20%の間で変動」を定義していない場合、完全性に反します。
1.  レバレッジ効果：収益率はレバレッジ効果に従います。つまり、$k$ 倍のレバレッジを使用する場合、結果 $i$ が発生したときの収益率は $k \cdot R_i$ となり、資産は元の $1 + k \cdot R_i$ 倍になります。
1.  ✅ 流動性が十分に高い投資商品はこの特性を満たします。
1.  ❌ 保有額が高すぎる場合、流動性の理由から市場インパクトコストが発生し、収益は線形関係に従わなくなります。

結果空間 $X$ に対して、**期待収益率 Expected Earning Yield** を計算できます：
$$E(X) = \sum_{i \in X} P_i R_i$$

期待収益率の考え方は直感的で計算も容易です。期待収益率の問題点は：

1.  導かれる意思決定が極端で、ポジションなしかフルポジションかのどちらかになり、破産リスクを制御できません。期待収益率が正の場合、たとえ高レバレッジが破産をもたらす可能性があっても、より高い収益率を求めてレバレッジを無限に拡大する傾向があります。
2.  複利効果を考慮していません。単一の投資の収益状況のみを考慮しており、市場が繰り返し投資可能であることを考慮していません。実際の投資管理の状況には適合しません。

**複利収益率 Compound Earning Yield** とは、独立した取引を複数回繰り返した後、1回の取引あたりに均等化された収益率のことです：

$$C(X, k) = (\prod_{i \in X} (1 + k \cdot R_i)^{P_i}) - 1$$

**最適収益率 Optimal Earning Yield** は、異なるレバレッジにおける複利収益率の最大値です：

$$O(X) = \max_k C(X, k)$$

破産してゼロにならないためには、すべての結果に対して $1 + k \cdot R_i >0$ が満たされる必要があり、これから $k$ の基本的な実行可能領域 $K$ を導出できます：

上限：

$$\max k = \max(0, \min_{R_i < 0} {-\frac{1}{R_i}})$$

下限：

$$\min k = \min(0, \max_{R_i > 0} {-\frac{1}{R_i}})$$

そして常に実行可能な解 $k = 0$ があります。

$$K = (\min k, \max k) \cup \{ 0 \}$$

最適レバレッジとは、実行可能領域 $K$ 内で複利収益率 $C(X, k)$ を最大化する $k$ のことです。

$$k_o = \argmax_k C(X, k)$$

任意の時点で、口座の実質レバレッジ $k = \frac{ポジション規模}{口座純資産}$ を計算でき、最適レバレッジ $k_o$ を評価できます。
すべての取引戦略は、最終的に実質レバレッジに対応します。確定的な取引意思決定を行うことは、$k$ の値を決定することと等価です。そして最適レバレッジは理想的なポジション保有に対応します。

これにより、以下の取引フレームワークが得られます：

1.  結果空間 $X$ を設計する。
2.  異なる結果の確率 $P$ を継続的に評価する。
3.  実質レバレッジ $k$ と最適レバレッジ $k_O$ を計算する。
4.  実質レバレッジを最適レバレッジに近づけるように制御する。

> **特殊点**
>
> 自明な点 $C(X, 0) = 0$、すなわち「参加しなければ損益は発生しない」。
> ポジションを持っていないとき、我々は $k = 0$ と決定したことと等価です。どの商品についても、ポジションの有無にかかわらず、我々は常に意思決定を行っています。
> 空売りは $k < 0$ の場合です。もし $|k| > 1$ ならば、追加のレバレッジが必要であることを意味します。

### 最適化問題の求解

問題を振り返ると、結果空間 $X$、確率分布 $P_i$、収益率 $E_i$、実行可能領域 $[L, R]$ が既知であり、収益率を最大化するレバレッジ率 $k \in [L, R]$ を求めることです：

複利収益率を移項整理し、両辺の対数を取ると（単調性は保持されます）、以下が得られます：

$$\ln (1 + C(X, k)) = \sum_{i \in X} P_i \ln (1 + k \cdot R_i)$$

ここで、

$$G(k) = \ln(1 + C(X, k)) = \sum_{i \in X} P_i \ln (1 + k R_i)$$

最適レバレッジの定義によると：

$$k_o = \argmax_k C(X, k)$$

$f(x) = \ln(1+x)$ は単調増加関数なので：

$$k_o = \argmax_k C(X, k) = \argmax_k G(k)$$

$G(k)$ の一次導関数、二次導関数を求めます：

$$G'(k) = \sum_{i \in X} \frac{P_i R_i}{1 + k R_i} $$

$$G''(k) = \sum\_{i \in X} -\frac{P_i R_i^2}{(1 + k R_i)^2} $$

二次導関数の各項は非正なので、$G''(k) \le 0$ です。$P_i R_i \equiv 0$ の場合に限り $G''(k) = 0$ となりますが、この場合 $G(k) \equiv 0$ となり、収益はなく実質的な意味はありません。それ以外の場合、$G''(k) < 0$ です。これは $G(k)$ が厳密な凹関数であり、$G'(k)$ が厳密に単調減少であることを意味します。$G(k)$ には唯一の極大点が存在し、この極大点が最大点です。

下図に示すように、項数がいくつであっても、$G(k)$ の曲線は凹関数です。

![ケリー公式-曲線の概略図](image-1.png)

$G(k)$ の極大点は、その一次導関数の零点です：

$$G'(k) = \sum_{i \in X} \frac{P_i R_i}{1 + k R_i} = 0$$

この方程式を整理すると、$k$ に関する多項式方程式に変換できます。
$R_i$ の異なる値が $N$ 個存在する場合、上記の多項式方程式の最高次数は $N-1$ です。
アーベル-ルフィニの定理によれば、五次以上の多項式には一般的な根の公式が存在しません。

一般的なケリー公式は、$N=2$ の特殊なケースです：勝率 $p$、オッズ $b$ とします。

| 結果 | 確率  | 収益率 |
| ---- | ----- | ------ |
| 勝ち | $p$   | $b$    |
| 負け | $1-p$ | $-1$   |

代入して方程式を得ます：

$$G'(k) = \frac{pb}{1+kb} + \frac{-(1-p)}{1 -k} = 0$$

整理すると、

$$k = \frac{p(b+1)-1}{b}$$

これがケリー公式です。

取引シナリオでは、異なる収益率の結果が無数に存在する可能性があるため、数値解を求めるしかありません。

単変数の厳密な凹関数として、ニュートン法を用いて求解することが最良の選択です。
不動点 $$G(0) = 0$$ から反復を開始するのは良い選択です。厳密な凹関数では、どの点から開始しても同じ結果に収束します。

#### ニュートン法が実行可能領域を超える場合

潜在的な問題は、ニュートン法で得られた反復点が、問題の実行可能領域を超える可能性があることです。
最小化の例でこの状況を説明します：

$$p_1 = 0.9, r_1 = 0.5, p_2 = 0.1, r_2 = -1$$

これより、

$$G(k) = 0.9 \times \ln(1+0.5k) + 0.1 \times \ln(1 - k)$$

![G(k) 関数のグラフ](image-2.png)

計算すると実行可能領域 $K = (-2, 1)$ であり、解析的な最適レバレッジ $k_o = 0.7$ が得られます。
しかし、ニュートン法を使用する場合、最初の反復点は

$$G(0) - \frac{G'(0)}{G''(0)} = \frac{14}{13} > 1$$

![G‘(k) 及びニュートン法のデモンストレーション](image-3.png)

最初の反復点で実行可能領域を超え、導関数の定義域を超えてしまうため、さらに反復することは意味がありません。これは、単純なニュートン法自体では実行可能領域を超える状況を処理できないことを示しています。

解決方法は、ニュートン法で反復点を計算した後、それが実行可能領域内にあるかどうかを追加で判断することです。領域内であればその点に反復し、領域外であればその方向に応じて、実行可能領域の境界と現在の点との間の点を次の反復点とします。

#### アルゴリズムの疑似コード

アルゴリズム $\text{resolve}(G, L, R, \epsilon = 10^{-9}, N = 100, \alpha = 0.9)$

1.  $k \gets 0$ で初期化
2.  収益率 $r_i$ に基づいて、基本的な実行可能領域 $K$ を計算
3.  実行可能領域をクリップ： $L \gets \max(L, \min K), R \gets \min(R, \max K)$
4.  最大 $N$ 回ループ：

    1.  次の点を計算：$k' \gets k - \frac{G'(k)}{G''(k)}$
    2.  もし $k'$ が $K$ に属さない場合

        1.  もし $k' \ge R$ なら、$k' \gets \alpha R + (1-\alpha)k$ とする
        2.  もし $k' \le L$ なら、$k' \gets \alpha L + (1 - \alpha) k$ とする

    3.  差が精度閾値 $| k' - k | < \epsilon$ より小さければ、ループを抜ける。
    4.  $k \gets k'$ で更新

5.  $k$ を返す

#### コード実装

プログラミングの観点では、より適切な抽象化は、結果集合の各結果が収益率 r と重み w の2つの属性を持つとすることです。この結果空間は走査可能であり、アルゴリズムは以下のように記述できます：

```ts
/**
 * ケリー基準に基づき、最適なレバレッジ k と期待収益 e を計算します。
 *
 * @param R - 収益率ベクトル
 * @param W - 重みベクトル
 * @param lower - 最小レバレッジ制限
 * @param upper - 最大レバレッジ制限
 * @param eps - 収束精度
 * @param max_iter - 最大反復回数
 * @param alpha - 収束加速係数
 * @returns 最適レバレッジ k と期待収益 e を含むオブジェクト
 */
export function resolve_k(
  R: number[],
  W: number[],
  lower = -Infinity,
  upper = Infinity,
  eps = 1e-9,
  max_iter = 100,
  alpha = 0.9
) {
  const n = R.length;
  if (n !== W.length)
    throw new Error(
      "Returning and Probability vectors must have the same length"
    );

  // 基本的な実行可能領域 K を計算 (1 + k * r > 0 となる領域)
  let minK = NaN;
  let maxK = NaN;
  for (let i = 0; i < n; i++) {
    const r = R[i];
    if (r === 0) continue;
    const k = -1 / r; // 臨界値
    if (r > 0) minK = isNaN(minK) ? k : Math.max(minK, k);
    if (r < 0) maxK = isNaN(maxK) ? k : Math.min(maxK, k);
  }
  if (isNaN(minK)) minK = 0; // 正の R がない場合、minK を 0 とする
  if (isNaN(maxK)) maxK = 0; // 負の R がない場合、maxK を 0 とする
  lower = Math.max(lower, minK);
  upper = Math.min(upper, maxK);

  let sum_w = 0;
  for (let i = 0; i < n; i++) {
    const w = W[i];
    if (w < 0) throw new Error(`Weight[${i}] = ${w} must be non-negative`);
    sum_w += w;
  }
  if (sum_w === 0) throw new Error("Sum of weights must be greater than zero");

  let k = 0;
  let it;
  for (it = 0; it < max_iter; it++) {
    let acc_g1 = 0;
    let acc_g2 = 0;
    for (let i = 0; i < n; i++) {
      const r = R[i];
      const w = W[i];
      acc_g1 += (w * r) / (1 + k * r);
      acc_g2 += (w * r * r) / (1 + k * r) ** 2;
    }
    const delta_k = acc_g1 / acc_g2;
    if (!(Math.abs(delta_k) > eps)) break;
    let next_k = k + delta_k;
    if (next_k <= lower) {
      next_k = lower * alpha + k * (1 - alpha);
    } else if (next_k >= upper) {
      next_k = upper * alpha + k * (1 - alpha);
    }

    k = next_k;
  }

  const lne =
    R.reduce((acc, r, i) => acc + W[i] * Math.log(1 + k * r), 0) / sum_w;
  const e = Math.exp(lne) - 1;

  return { k, e, it, sum_w, lne, upper, lower };
}
```

### その他の数学的性質

#### 実行可能領域が制限されない場合、期待収益率が正ならば最適収益率も正

証明：
$f(x) = \ln(1+x)$ は $x$ と符号が同じなので、$C(X, k) $ と $G(k)$ の符号は同じです。
$G(k)$ の $k = 0$ における導関数を考えます：$G'(0) = \sum_{i \in X} P_i R_i $、これは実際には期待収益率 $E(X)$ です。
微小量 $\Delta k$ に対して、導関数の定義により、$G(\Delta k) = G(0) + G'(0) \cdot \Delta k = E(X) \cdot \Delta k$

もし $E(X) > 0$ ならば、$G(\Delta k) > 0$、すなわち $C(X, \Delta k) >0$ となる $\Delta k > 0$ が存在します。そして最適収益率は
$$O(X) = \max C(X, k) \ge C(X, \Delta k) > 0$$

証明終わり。

この他に、以下の表の結論が証明できます：

| 期待収益率 | 最適レバレッジ | 最適収益率 |
| ---------- | -------------- | ---------- |
| 正         | 正             | 正         |
| 0          | 0              | 0          |
| 負         | 負             | 正         |

## FSA の歴史的バックテスト手法

### 粗利益率：Gross Profit Margin, GPM

取引フレームワークで述べたように、各時点で実質レバレッジ $k$ と最適レバレッジ $k_O$ を計算し、実質レバレッジを最適レバレッジに近づけるように制御できます。

ここでは、**単利** によるバックテスト方式をデフォルトとします。なぜなら、複利モデルは後のコスト推定に影響を与え、複利モデルは非常に大きな取引高の変動を生み出し、戦略容量に達した後、市場に追加のインパクトコストを発生させ、実際に約定可能な量やコストがモデル値から大きく乖離し、バックテストの信頼性を損なうためです。実際のシナリオでは、複利操作は多くの場合人為的に制御されます。つまり、初期純資産や取引倍数を主観的に調整して、「単利」と「複利」の間の「部分複利」方式を生み出します。

重要な制約： $K_t$ は $0, 1, ..., t$ 時点の既知情報のみに依存し、未来関数は存在しません。$K_t$ は $t+1$ 時点の保有量に影響を与えます。

歴史的バックテストを行うには、まず価格 $P_t$ と対応する計画純保有量 $V_t$ を知る必要があります。

ミクロ的に見ると、$t$ 時点では、価格 $P_t$ を知ると同時に、純資産 $E_t$ と純保有量 $H_t$ も知ります。

境界条件を考えます：$V_0 = 0, E_0 = 0$。

無視できるほどの分析時間を経て、計画純保有量 $V_t$ が得られます。

ポジション調整に必要な取引量は $V_t - H_t$ です。

その後、$t + 1$ 時点までに、直ちに注文を開始します。

流動性が十分にあると仮定すると、$P_{t+1}$ の価格で完全に約定し、$H_{t+1} = V_t$ となります。
$c$ を取引高に基づくコスト率とすると、コストは $c \cdot |V_t - H_t| \cdot P_{t+1}$ です。
また、純保有 $H_t$ は価格変動の影響を受け、損益 $H_t (P_{t+1} - P_t)$ を生み出します。

以上をまとめると、$t + 1$ 時点では：

$$H_{t+1} = V_t$$
$$E_{t+1} = E_t + H_t (P_{t+1} - P_t) - c \cdot |H_{t+1} - H_t| \cdot P_{t+1}$$

単利モードでは、保有量と取引コストは初期純資産に比例します。

保有後の価格変動による総利益（Profit and Loss, PnL）：

$$\text{PnL} = \sum_t H_t \cdot (P_{t + 1} - P_t)$$

総取引高：

$$\text{Turnover} = \sum_t |H_{t+1} - H_t| \cdot P_{t+1}$$

モデルが収支トントンとなる最大の取引コスト率、すなわち粗利益率(Gross Profit Margin, GPM) を推定できます：

$$\text{GPM}  = \frac{\text{PnL}}{\text{Turnover}}$$

その後、実取引では、この GPM を下回る実際のコスト率であれば利益を上げることができます。この GPM はモデルの容量を示唆しており、GPM が大きいほど、実取引時に大きな取引スリッページを使用でき、実際の取引量を増やすことができます。

モデルの任務は GPM を最大化することであり、取引モジュールの任務はこの GPM 制約下で利益を実現することです。具体的には、その後の実取引において、取引モジュールの任務は、GPM を超えない範囲で、できるだけ多くの取引高を達成することです。取引モジュールは取引所固有の手数料率を回避できず、手数料率はVIP、リベート、メイカー/テイカーなどの様々な要因によって影響を受ける可能性があります。モデルの GPM がある取引所の手数料率より大きい場合、そのモデルはその取引所で利益を上げるのが難しいと考えられ、モデルの改善が必要です。取引モジュールが現在の任務を達成できないと判断した場合、取引高を減らすか、取引を行わずにポジションをゼロに保つことを選択できます。

最終的な利益は、取引高 \* (GPM - 実際のコスト率) と考えることができます。初期純資産を増やすと取引高が増加し、実際のコスト率が GPM に限りなく近づき、利益がなくなるまで続きます。しかし、式から見ると、利益の最適化問題が存在するはずです。この最大利益に対応する初期純資産が取引モデルの容量となります。具体的な評価には、取引高とコストの関係をさらに深く研究する必要があります。

### 保有分解能

実際の取引では、商品には最小取引量のステップ（volume_step）があり、ポジションはステップの整数倍でのみ取引できます。
したがって、浮動小数点数の目標ポジションが与えられても、この目標ポジションを100%追従することはできません。そのため、この目標ポジションを取引可能なポジションに丸める必要があります。

保有分解能, Holding Resolution は正の整数です。

最適レバレッジ $k_O$ に対して単利法を適用し、分解能マッピングを通じて目標ポジション $V$ を得た場合、バックテストフレームワークに代入すると MER を計算できます。

-   保有分解能 = 1 の場合、戦略は基本ポジションのみを取引することを意味します。つまり、目標ポジションの値は -1, 0, 1 です。
-   保有分解能 = 2 の場合、戦略はポジション分割を必要とし始めます。目標ポジションの値は -2, -1, 0, 1, 2 です。
-   保有分解能 = ∞ の場合、戦略は任意の精度でポジションを調整できることを意味します。しかし、これは実際の状況には適合しません。

保有分解能が低いほど、後の少額資金での実取引に必要な基礎資金は少なくなりますが、利用される情報は曖昧になります。

理論的には、保有分解能は取引高に影響を与えます。分解能が低いほど、取引高は低くなります（本来ポジション調整が必要な状況が不要になります）。保有分解能が収益に与える影響は明確ではありません。経験上、MER が十分に高く、分解能に鈍感であれば、直接実取引に移行できることを意味します。

## 実取引モジュール

実取引モジュールは、MER 制約下で利益を実現する必要があります。

しかし、建玉と決済の制約は一致しません。建玉時には目標取引高が完全に約定しなくても許容できますが、決済時にはこれを許容できません。したがって、決済時には制約が厳しく、最悪の場合、成行注文で約定することになり、高い手数料とスリッページが発生します。

成行注文のコスト率を $c$ と仮定すると、建玉時には $2 \times \text{MER} - c$ 以下のコスト率で建玉する必要があり、安全です。

例えば MER = 0.02%、成行注文コストが 0.03% の場合、建玉コストは最大 0.01% です。

## 結果空間について

### ブラックスワンへの対応策

ブラックスワンとは、極めて発生する可能性が低いが、実際には発生する事象のことです。

1.  ブラックスワンが発生する確率は、いかなるモデルでも推定できず、ブラックスワンに対するいかなる推定も無駄であり、その確率は不可知です。
2.  ブラックスワン事象が発生すると、非常に大きな損失が生じます。
    そのため、いかなる結果空間を設計する際にも、ブラックスワン事象の発生を防御する必要があります。
3.  ブラックスワンが発生すると、必ず -100% の収益率、すなわち全額損失が発生します。
4.  ブラックスワンは、既知のサンプルを用いて、いかなる確率分布でも適合させることはできません。
    したがって、ブラックスワン事象に対して擬似的な確率を設定することは必要です。

既存のサンプルから、設定した結果空間 $X$ に確率 $P_i$ を割り当てたと仮定します。

人為的に、2つの対称的なブラックスワン事象を追加する必要があります：$P_b^- = 0.0013, r_b = -1, P_b^+ = 0.0013, r_b = 1$。ここで 0.0013 は正規分布における $3\sigma$ 外の確率で、約770サンプルに1回発生する程度です。ブラックスワン事象に割り当てる確率が大きいほど、戦略は保守的になります。

対称的なブラックスワン事象を設計するのは、期待収益率に影響を与えず、最適レバレッジの符号を変えさせないためです。これにより、本来レバレッジが0の場合に、空売りが必要と判断される事態を防ぎます。

元の確率は、新しい結果空間の完全性を保証するために、$1 - P_b^- - P_b^+ = 0.9974$ 倍に縮小する必要があります。

ブラックスワン事象を追加すると、実行可能領域が縮小し、最適レバレッジ率は厳密に $(-1, 1)$ の範囲内に制限されます。空売りは可能ですが、追加のレバレッジをかけることはできません。ブラックスワン事象の追加は、レバレッジの乱用問題を効果的に防止できます。

```ts
export function withBlackSwan(R: number[], W: number[], Pb = 0.0013) {
  const sum_w = W.reduce((acc, cur) => acc + cur, 0);
  const w_b = (Pb * sum_w) / (1 - 2 * Pb);
  return {
    R: R.concat([1, -1]),
    W: W.concat([w_b, w_b]),
  };
}
```

## まとめ

与えられた結果空間 $X$ に対して、$R_i$ は確定しており、結果空間内の確率分布 $P_i$ を推定できれば、確定的な最適レバレッジ $k_O$ が得られます。取引システムが一貫しているべきだと考えるなら、その確率は繰り返し可能であるはずであり、この状況下では、全スペクトル分析法は不完全な情報を損失なく活用します。したがって、この最適レバレッジを厳密に遵守しない理由はありません。

一部の取引システムは、最も発生確率の高い結果を求め、その結果に基づいて取引計画を立てようとします。これは最尤法です。この方法のリスクは、尤度関数が比較的平坦な場合、いずれかの解釈を選択することは十分に正確ではないということです。このような戦略は、効果的なときもあれば無効なときもあるように見えます。一方、全スペクトル分析法は最高確率の結果に従う必要はなく、異なる結果における収益を計算し、最適なポジションを選択できます。それは微妙な情報を捉え、最適な意思決定を行うことができます。したがって、全スペクトル分析法は、情報を収益化するための品質のハードルを大幅に下げます。

結果空間を設計し、確率分布を推定する方法については、収益化される