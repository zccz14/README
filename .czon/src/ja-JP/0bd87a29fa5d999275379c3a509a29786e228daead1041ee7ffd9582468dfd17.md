---
"title": "AIプログラミング実践の振り返り：OOPと過剰な互換性を避ける"
"summary": "本稿では、著者がAIを用いたプログラミング（Vibe Coding）に失敗した経験を記録しています。AIが生成したオブジェクト指向コードは品質が低く、構造が混乱しており、技術的負債が爆発的に増加しました。著者は、AIのOOPパラダイムに対する設計能力不足、アーキテクチャガイダンスの欠如、過剰な後方互換性など、その原因を分析しています。記事では、重要な提言として、オブジェクト指向プログラミングの使用を避け、手続き型および関数型プログラミングへ移行すること、AIにオッカムの剃刀の原則を理解させ、コードの肥大化を減らすことを提案しています。これらの対策は、AIが生成するコードの品質と保守性を向上させることを目的としています。"
"tags":
  - "AIプログラミング"
  - "オブジェクト指向プログラミング"
  - "関数型プログラミング"
  - "コード品質"
  - "技術的負債"
  - "オッカムの剃刀"
  - "後方互換性"
"date": "2026-01-07"
---

今日は2026年1月7日です。

Vibe Codingの使用は大失敗でした。AIが書いたコードの品質は非常に低く、全く使い物になりませんでした。やむを得ず、ZENプロジェクトをすべて書き直し、従来の伝統的な手法によるプログラミングで実装し直しました。

私はAIを使用してゼロからコードを生成し、何度も繰り返し改善を試みましたが、プロジェクトの品質は崩壊し始め、新機能を統合できなくなり、バグが次々と発生し、コード構造は混乱し、機能の削除さえ異常に困難になりました。これは技術的負債が爆発的に増加する典型的な症状です。そこで、私は果断に介入し、プロジェクト全体を書き直すことを決断しました。特に重要な発見は、AIが書くOOPコードの品質が特に悪いことです。新しい機能があるたびに単独のクラスを作成し、関連する他のクラスに穴を開けてそれを呼び出すという方法で、大量の無駄なクラスとメソッドが生まれていました。これはオブジェクト指向プログラミングではなく、明らかに「要求仕様書指向プログラミング」です。

その原因として、私は以下の点を考えています：

1.  AIはオブジェクト指向プログラミングのパラダイム設計能力が不足しており、これはビジネスドメインの概念に対するモデリング能力の欠如による可能性があります。
2.  AIは、自分が書いているコードが一時的なものなのか、長期的に保守されるものなのかを理解しておらず、アーキテクチャのガイダンスがなく、手抜きで一気に進める戦略を取っています。
3.  AIに適した足場（スキャフォールディング）がなく、AIがゼロから自力で立ち上げるプロセスは非常に困難です。
4.  AIは互換性に対する要求を過度に保守的に捉えすぎており、コードを肥大化させています。

## オブジェクト指向の誤解

私は、AIは現時点ではオブジェクト指向プログラミングのコードを書くのに適していないと考えます。オブジェクト指向プログラミングは、ビジネスドメインに対する深い理解とモデリング能力を要求しますが、AIは現時点ではこの点を満たすことができません。むしろ滑稽なことに、人間でさえもこの作業を容易にこなすことはできません。一方で、手続き型プログラミングや関数型プログラミングは、オブジェクトの状態や振る舞いよりも、データの変換と処理に焦点を当てるため、AIにはより適しています。

もしオブジェクト指向を使用するなら、AIにデザインパターンとリファクタリングの両方に精通させる必要があります。そうすることで、高品質なオブジェクト指向コードを書くことができます。しかし、手続き型や関数型プログラミングを使用する場合、AIはアルゴリズムとデータ構造に集中するだけで、十分なコードを書くことができます。

では、オブジェクト指向の利点は何でしょうか？カプセル化？継承？多態性？これらはAIの時代にはそれほど重要ではないように思えます。なぜなら、これらはコードを少なく書くためや、チームでの分業・協業のために生まれたものであり、AIには関係がないからです。むしろ、コードの可読性、保守性、テスト容易性が重要です。そして、これらの特性は、関数型プログラミングや手続き型プログラミングによってより容易に実現できます。

## 過剰な後方互換性

AIは後方互換性に対する要求が過度に保守的であり、コードを肥大化させています。AIは常に既存のコードを壊さないように、すべての古い機能とインターフェースを保持しようと試みます。しかし、この方法は往々にして逆効果です。なぜなら、コードの複雑さと保守コストを増加させるからです。時には、古い機能やインターフェースを削除することで、コードを簡素化し、パフォーマンスを向上させることができます。しかし、AIはビジネス要件やユーザーの行動に対する理解が不足しているため、このようなトレードオフを判断することが困難です。

もしAIがすべてのpublic exportを保持する必要があると考えているなら、新機能を作成する際にこれらのインターフェースを安易に導入し、その後の保守ではこれらの不要なインターフェースを宝物のように扱い、うっかり削除してしまうことを恐れます。その結果、コードはますます肥大化し、複雑さが増し、バグも増えていきます。

私はAIに「破壊的変更を許可する」戦略を使用するよう導いたところ、効果は明らかに改善されました。これは、問題の所在を特定できたことを示しています。しかし、これも新たな問題を引き起こします：破壊的変更のリスクをどのように管理するか？

AIに**オッカムの剃刀**の原則を理解させなければなりません：必要がなければ、実体を増やしてはならない。
つまり、コードは可能な限りシンプルにし、不必要な複雑さと冗長性を避けるべきです。本当に必要な場合にのみ、新しい機能やインターフェースを導入すべきです。そうすることで、コードの明確さと保守性を保つことができます。

AIが設計タスクとコーディングタスクを分離しなければ、この点を実現することは困難です。

## 結論

1.  **OOPを使用せず、手続き型および関数型プログラミングへ移行することを強調します。** これは非常に重要な近道であり、AIが生成するコードの品質と保守性を大幅に向上させることができます。
2.  **AIにオッカムの剃刀の原則を理解させ、過剰な後方互換性を避け、コードの肥大化を減らします。**

その他、例えば足場（スキャフォールディング）の問題や、アーキテクチャガイダンスの問題などについては、まだどうすればよいか考えがまとまっていません。