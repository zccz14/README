---
"title": "AIエージェントのモジュールレベルにおけるソフトウェア工学アーキテクチャ設計に関する考察"
"summary": "本稿は、2026年1月12日時点での筆者の、AIエージェントをモジュールレベルのソフトウェア工学に適用する際の考察を記録したものです。筆者は、人と機械が協調するアーキテクチャを提案し、その要点として、git worktreeを用いたコードリポジトリの管理、CLIによるAIエージェント（Claude Codeなど）の呼び出しとセッション管理、エージェントからの終了通知と対話履歴の取得による透明性の実現を挙げています。筆者は、各タスクを独立したエージェントセッションに割り当て、スケジューラによってワークフローを調整する自動化スクリプトの実装を計画しています。本稿では、LLM APIを直接呼び出すのではなくエージェントを利用する利点、すなわち、エージェントがコードベースの探索、システムコマンドの呼び出し、コンテキスト管理といった複雑な下位処理を担当し、車輪の再発明を避けられる点を強調しています。筆者はまず、この考え方を検証するための簡易版の実装を目指しています。"
"tags":
  - "AIエージェント"
  - "ソフトウェア工学"
  - "人機協調"
  - "Claude Code"
  - "自動化"
  - "モジュール化"
  - "透明性"
  - "スケジューラ"
"date": "2026-01-12"
---

今日は2026年1月12日、月曜日の朝です。

今朝早く起きて、昨日C1と議論したAIエージェントの設計問題を振り返り、いくつかの示唆を得たので、記録しておく必要があると考えました。

[前回の記事](../INSIGHTS/1.md)を参考に、私はモジュールレベルでの人機協調ソフトウェア工学アーキテクチャを設計しました。

私はその実現方法について考えています。

簡単に言えば、重要なポイントは以下の通りです：

1.  `git worktree` コマンドを使用してコードリポジトリを管理し、各リポジトリにセットアップスクリプトを用意する必要があります。
2.  CLIを通じてAIエージェント（Claude Code, OpenCode, ...など）を呼び出し、プロンプトを渡してセッションを開始する必要があります。
3.  AIエージェントからの終了通知を受け取れる必要があります。
4.  AIエージェントの中間的な対話履歴を取得できる必要があります。そうでなければ透明性を達成できません。[この文書](../INSIGHTS/2.md)で言及されている「制御可能な信頼性」の問題を参考にすると、私たちには「事中の透明性と制御性」が必要です。

これらの機能に基づいて、モジュールレベルのソフトウェア工学タスクを完了するための自動化スクリプトを実装することができます。

Claude Codeを例にとると、

1.  Claude Codeは、CLIから直接プロンプトを渡すことで、新しいセッションを開始できます。
2.  Claude Codeは、`-p` パラメータを使用して、結果を標準出力に出力する際に終了を識別できます。
3.  Claude CodeはセッションIDを渡す機能を提供しており、それによって `.claude` ディレクトリ内の対応する対話履歴ファイルを見つけ、過去のメッセージを取得できます。

そうであれば、これらの作業を管理するスクリプトを書くことができます。

各セッションは独立しており、クリーンです。各セッションは、1つのエージェントが完了するために割り当てられます。

1つのエージェントインスタンスは、その基盤がClaude Codeであろうと他のものであろうと関係なく、インターフェースとして抽象化できます。

そしてスケジューラは、事前に定義されたワークフローに基づいて、異なるエージェントをタスク完了のために調整します。

なぜLLM APIではなくエージェントを基盤とするのでしょうか？それは、エージェントがコードベースの探索、オペレーティングシステムコマンドの呼び出し、コンテキスト管理、LLM APIへの適応といった複雑な下位ロジックを処理してくれるからです。これは複雑なシステムであり、要求を満たさない場合を除き、車輪の再発明は必要ないと考えます。

私はまず、この考え方が実現可能かどうかを検証するための最も簡素化されたバージョンを実装する予定です。今後の進展記録にご期待ください。