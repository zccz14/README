---
"title": "Multi-Agentsによる対抗生成翻訳と最適化戦略"
"summary": "本稿では、Multi-Agentsを翻訳タスクに応用する方法を探る。対抗生成モデル（翻訳モデルと審査モデルの対抗）を通じて翻訳品質を大幅に向上させ、内容の欠落、不連続性、不自然さの問題を解決するが、時間とToken効率を犠牲にする。また、メモリ最適化戦略についても議論し、すべてのAgentを単一プロセスに統合してメモリを節約する方法を提案する。制御制約の観点では、ソフト制約とハード制約の利点を組み合わせ、Orchestrator AgentがScriptを生成して柔軟かつ信頼性の高い制御を実現する方法を提案する。さらに、OpenCodeとClaudeのエコシステムの開放性を比較し、OpenCodeのAPIフレンドリーな特性が統合を容易にする点を強調する。"
"tags":
  - "Multi-Agents"
  - "対抗生成翻訳"
  - "メモリ最適化"
  - "制御制約"
  - "OpenCode"
  - "Claude"
  - "翻訳品質"
  - "Agent協調"
"date": "2026-01-25"
---

現在は2026年1月25日、日曜日の午後です。

**Multi-Agents: 対抗生成翻訳**

昨日、CZONの軽量なOpenCode翻訳統合を完了し、基本的な対抗生成モデルを実装しました。

この翻訳タスクでは、翻訳タスクと審査タスクを導入しています。両者は対抗生成を行い、翻訳モデルは翻訳結果を生成し、審査モデルは翻訳結果が合格かどうかを審査します。審査モデルが翻訳結果を不合格と判断した場合、翻訳モデルに再生成を要求し、合格する翻訳結果が生成されるまで続けます。（現在は最大10回の反復回数で、無限ループを防止しています）

この翻訳設計は、元のone-shot LLM翻訳と比較して、時間とToken効率を犠牲にしています。しかし、重要な利点があります：翻訳品質を大幅に向上させ、以下の問題を解決します：

1. 翻訳内容の欠落問題：一部の翻訳モデルは原文の一部の内容を漏らし、翻訳結果が不完全になることがあります。審査モデルは翻訳結果がすべての原文内容を含んでいるかどうかをチェックし、翻訳の完全性を確保します。
2. 長文翻訳の不連続性問題：一部の翻訳モデルは長文を処理する際、前後の一貫性が失われることがあります。審査モデルは翻訳結果の一貫性をチェックし、翻訳結果が全体的に一致していることを確保します。
3. 不自然でぎこちない問題：一部の翻訳モデルが生成する翻訳結果は、不自然でぎこちない場合があります。審査モデルは翻訳結果の流暢さを評価し、翻訳結果が目標言語の表現習慣に合致していることを確保します。

結果から見ると、翻訳品質の優先度は明らかにToken効率や時間効率よりも高いです。CZONのような高品質翻訳が必要なシナリオでは、対抗生成モデルは良い選択肢です。

**Multi-Agentsのメモリ最適化**

各Agentごとに個別のプロセスを起動することはできません。各プロセスは少なくとも100MBのメモリを消費し、複数のAgentが同時に実行されるとメモリ不足になります。より良い方法は、すべてのAgentを単一のプロセスに統合して実行し、メモリオーバーヘッドを節約することです。OpenCode公式はServerとClientを分離しており、1つのserveプロセスでポート（デフォルトは4096）を監視し、複数のClientがこのポートに接続して対話できます。これにより、すべてのAgentを単一のServerプロセスに統合して実行でき、Clientはリクエストの送信とレスポンスの受信のみを担当します。

このようにすれば、メモリ不足によるクラッシュを起こすことなく、数百の翻訳タスクを同時に起動できるはずです。

**Multi-Agentsの制御制約**

業界には2つのアプローチがあります。1つはAgentがAgentを制御する方法、もう1つはScriptがAgentを制御する方法です。

違いは、AgentがAgentを制御するのはソフト制約であり、Agentは自身の判断に基づいて他のAgentの指示を実行するかどうかを決定できます。一方、ScriptがAgentを制御するのはハード制約であり、AgentはScriptの指示に厳密に従って実行しなければなりません。

ソフト制約の利点は柔軟性であり、欠点は信頼性の低さです。ハード制約の利点は信頼性であり、欠点は柔軟性の低さです。

ソフト制約の問題はよく見られます。Agentにworkflowを定義しても、Agentはこのworkflowに従ってタスクを実行せず、早期に終了して結果が期待通りにならないことがよくあります。一方、ハード制約の問題は、Scriptがすべてのシナリオをカバーできないため、Agentが特定の特殊な状況を処理できないことです。

両者は一見相容れないように見えますが、実際には、Orchestrator Agentを使用してScriptを生成し、他のAgentにこのScriptに従ってタスクを実行させることができます。これにより、両方の利点を組み合わせ、柔軟性と信頼性の両方を実現できます。初期段階では、Agentの動作を制御するために手動でScriptを記述することもできます。完全な制御こそが最大の柔軟性です。

したがって、ScriptがAgentを呼び出す際の摩擦を十分に小さくし、1行のコードでスケジューリングを実現し、複雑な多Agent協調作業を実現する必要があります。

AnthropicのMulti-Agentに関する[記事](https://www.anthropic.com/engineering/multi-agent-research-system)では、サブAgentの出力は主調整器に返すのではなく、ファイルシステムに書き込むことが推奨されています。したがって、ScriptがAgentを呼び出す際には結果を返す必要はなく、Agentが結果をファイルシステムに書き込み、他のモジュールがファイルシステムから結果を読み取るだけでよいと考えられます。

さらに、ScriptはJSなどの一般的な言語に統合でき、1つのライブラリを利用すれば、Orchestrator AgentがまずScriptをコード化し、その後Scriptが他のAgentを呼び出してタスクを実行できます。DSLを使用せずに、DSLを超えることができます。

**Multi-Agentsエコシステム: OpenCode vs Claude Code**

OpenCodeのエコシステムは明らかにClaudeよりも開放されています。OpenCodeはHTTP API（またはSDK）を通じてAgentを呼び出し、Agent Sessionの状態を確認し、Agentの出力結果を取得することを許可しています。これにより、OpenCode Agentを私たちのシステムに統合し、複雑な多Agent協調作業を実現することがより簡単になります。一方、Claudeは逆の道を歩み、生態系を閉鎖しようとし、Anthropicが提供するインターフェースを通じてのみClaude Agentを呼び出すことを許可し、ユーザーの自由度を制限しています。