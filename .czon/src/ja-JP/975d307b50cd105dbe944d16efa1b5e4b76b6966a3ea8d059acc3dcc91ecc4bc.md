---
title: AIプログラミングの失敗と書き直しの経験
summary: 著者はAIが生成したオブジェクト指向コードの品質の低さと技術的負債の爆発的増加により、ZENプロジェクトを全面的に書き直し、手続き型および関数型プログラミングへ移行しました。また、過度な後方互換性の回避によるコード品質向上を提案しています。
tags:
  - AIプログラミング
  - オブジェクト指向プログラミング
  - 関数型プログラミング
  - 技術的負債
  - コード品質
  - オッカムの剃刀
  - 後方互換性
inferred_date: 2025-01-07
inferred_lang: zh-Hans
---

今日は2025年1月7日です。

Vibe Codingの使用は大失敗でした。AIが書いたコードの品質は低すぎて、全く使い物になりませんでした。やむを得ず、ZENプロジェクトをすべて書き直し、従来の「古式プログラミング」で実装することにしました。

私はAIを使用してコードをゼロから生成し、何度も繰り返し改善を試みましたが、プロジェクトの品質は崩壊し始めました。新機能を統合することができず、バグが次々と発生し、コード構造は混乱し、機能の削除さえ異常に困難になりました。これは技術的負債が爆発的に増加した典型的な症状です。そこで、私は果断に介入し、プロジェクト全体を書き直すことを決断しました。特に気づいたのは、AIが書いたOOP（オブジェクト指向プログラミング）コードの品質が極めて低いことです。AIは新しい機能ごとに単独のクラスを作成し、関連する他のクラスに穴を開けてそれを呼び出すという方法を取っていました。その結果、大量の無駄なクラスとメソッドが生まれました。これはオブジェクト指向プログラミングではなく、まさに「要求仕様書指向プログラミング」と言える状態でした。

その原因として、私は以下の点を考えています：

1.  AIはオブジェクト指向プログラミングのパラダイムを設計する能力が不足しています。これは、ビジネス領域の概念をモデル化する能力が欠如しているためかもしれません。
2.  AIは、自身が書いているコードが一時的なものなのか、長期的に保守されるものなのかを理解していません。アーキテクチャの指針がなく、手抜きで一気に進める戦略を取っています。
3.  AIに適した開発基盤（スキャフォールディング）が不足しており、AIがゼロから自力で構築するプロセスは非常に困難です。
4.  AIは互換性の要求を過度に保守的に捉えすぎており、その結果、コードが肥大化しています。

## オブジェクト指向の神話

私は、AIは現時点ではオブジェクト指向プログラミングのコードを書くのに適していないと考えます。オブジェクト指向プログラミングは、ビジネス領域に対する深い理解とモデリング能力を要求しますが、AIは現在この点を満たすことができません。皮肉なことに、人間でさえもこれを容易に達成できるわけではありません。逆に、手続き型プログラミングや関数型プログラミングはAIに適しています。なぜなら、これらはオブジェクトの状態や振る舞いよりも、データの変換と処理に焦点を当てているからです。

もしオブジェクト指向を使用するのであれば、AIにデザインパターンとリファクタリングの両方を精通させる必要があります。そうすることで、高品質なオブジェクト指向コードを書くことができます。一方、手続き型や関数型プログラミングを使用する場合、AIはアルゴリズムとデータ構造に集中するだけで、十分なコードを書くことができます。

では、オブジェクト指向の利点は何でしょうか？カプセル化？継承？多態性？これらはAIの時代にはそれほど重要ではないように思えます。なぜなら、これらはコードを少なく書くためや、チームでの分業・協業のために生まれた概念であり、AIには関係がないからです。逆に、コードの可読性、保守性、テスト容易性こそが重要です。そして、これらの特性は関数型プログラミングや手続き型プログラミングを通じてより容易に実現できます。

## 過度な後方互換性

AIは後方互換性の要求に対して過度に保守的であり、その結果、コードが肥大化してしまいます。AIは既存のコードを壊さないように、すべての古い機能とインターフェースを保持しようとします。しかし、この方法は往々にして逆効果です。なぜなら、コードの複雑さと保守コストを増加させるからです。時には、古い機能やインターフェースを削除することで、コードを単純化し、パフォーマンスを向上させることができます。しかし、AIはビジネス要件やユーザーの行動を理解していないため、このようなトレードオフを判断することが難しいのです。

もしAIがすべての公開エクスポート（public export）を保持すべきものと認識してしまうと、新機能を作成する際にこれらのインターフェースを安易に導入し、その後の保守ではこれらの不要なインターフェースを宝物のように扱い、うっかり削除してしまうことを恐れるようになります。その結果、コードはますます肥大化し、複雑さが増し、バグも増えていきます。

私はAIに「破壊的変更を許可する」戦略を使用するよう導いてみたところ、効果は明らかに改善されました。これは、問題の所在を特定できたことを示しています。しかし、これには新たな問題も生じます：破壊的変更のリスクをどのように管理するか？

AIに**オッカムの剃刀**の原則を理解させなければなりません：必要がなければ、実体を増やしてはならない。
つまり、コードは可能な限り単純であるべきで、不必要な複雑さと冗長性を避けるべきです。本当に必要な場合にのみ、新しい機能やインターフェースを導入するべきです。そうすることで、コードの明確さと保守性を保つことができます。

AIが設計タスクとコーディングタスクを分離しなければ、これを実現することは難しいでしょう。

## 結論

1.  OOPを使用せず、手続き型および関数型プログラミングへ移行することを強調します。これは非常に重要な近道であり、AIが生成するコードの品質と保守性を大幅に向上させることができます。
2.  AIにオッカムの剃刀の原則を理解させ、過度な後方互換性を避け、コードの肥大化を減らすように導きます。

その他、例えば開発基盤（スキャフォールディング）の問題や、アーキテクチャの指針の問題などについては、まだどうすればよいか考えがまとまっていません。