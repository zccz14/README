---
"title": "Reflexión sobre la práctica de programación con IA: Evitar la POO y la compatibilidad excesiva"
"summary": "Este artículo documenta la experiencia fallida del autor al usar IA para programar (Vibe Coding), descubriendo que el código orientado a objetos generado por la IA era de baja calidad y tenía una estructura caótica, lo que llevó a una explosión de deuda técnica. El autor analiza las causas, incluyendo la capacidad insuficiente de la IA para diseñar paradigmas de POO, la falta de orientación arquitectónica y la compatibilidad excesiva hacia atrás. El artículo propone recomendaciones clave: evitar la programación orientada a objetos y cambiar a la programación orientada a procesos y funcional; guiar a la IA para que comprenda el principio de la navaja de Ockham y reduzca la hinchazón del código. Estas medidas tienen como objetivo mejorar la calidad y mantenibilidad del código generado por la IA."
"tags":
  - "Programación con IA"
  - "Programación orientada a objetos"
  - "Programación funcional"
  - "Calidad del código"
  - "Deuda técnica"
  - "Navaja de Ockham"
  - "Compatibilidad hacia atrás"
"date": "2026-01-07"
---

Hoy es 2026-01-07.

Un gran fracaso con Vibe Coding: el código que la IA me escribió era de muy baja calidad y completamente inutilizable. Me vi obligado a reescribir completamente el proyecto ZEN, utilizando métodos de programación tradicionales y antiguos.

Usé la IA para generar código desde cero. Después de varias iteraciones, la calidad del proyecto comenzó a colapsar: las nuevas funciones no podían integrarse, los errores proliferaban, la estructura del código era caótica e incluso eliminar funciones se volvió excepcionalmente difícil. Estos son síntomas típicos de una explosión de deuda técnica. Por lo tanto, intervine decididamente y decidí reescribir todo el proyecto. Lo más crítico fue descubrir que el código orientado a objetos escrito por la IA era especialmente deficiente: cada nueva función generaba una clase separada, y luego se perforaba un agujero en otras clases relacionadas para llamarla, lo que resultó en una gran cantidad de clases y métodos inútiles. Esto no es programación orientada a objetos, sino programación orientada a una lista de requisitos.

Las razones, en mi opinión, son:

1. La capacidad de la IA para diseñar paradigmas de programación orientada a objetos es insuficiente, probablemente debido a la falta de modelado de conceptos del dominio del negocio.
2. La IA no distingue si está escribiendo código desechable o para mantenimiento a largo plazo, carece de orientación arquitectónica y adopta una estrategia perezosa de "hacerlo todo de una vez".
3. Falta un andamiaje amigable para la IA, lo que hace que el proceso de arranque desde cero sea difícil.
4. La IA es demasiado conservadora en cuanto a los requisitos de compatibilidad, lo que lleva a un código hinchado.

## El mito de la programación orientada a objetos

Creo que la IA actualmente no es adecuada para escribir código orientado a objetos. La programación orientada a objetos requiere una comprensión profunda y capacidad de modelado del dominio del negocio, algo que la IA aún no puede manejar. Incluso, de manera bastante ridícula, los humanos tampoco pueden hacerlo fácilmente. Por el contrario, la programación orientada a procesos y funcional es más adecuada para la IA, ya que se centra más en la transformación y procesamiento de datos que en el estado y comportamiento de los objetos.

Si usas programación orientada a objetos, necesitas que la IA domine tanto los patrones de diseño como la refactorización para poder escribir código de alta calidad. En cambio, con la programación orientada a procesos y funcional, la IA solo necesita centrarse en algoritmos y estructuras de datos para producir un código decente.

Entonces, ¿cuáles son los beneficios de la programación orientada a objetos? ¿Encapsulación? ¿Herencia? ¿Polimorfismo? En la era de la IA, estos parecen menos importantes, ya que existen principalmente para escribir menos código y facilitar la colaboración en equipo, cosas que a la IA no le importan. Por el contrario, la legibilidad, mantenibilidad y capacidad de prueba del código son clave. Y estas características son más fáciles de lograr mediante la programación funcional y orientada a procesos.

## Compatibilidad excesiva hacia atrás

La IA es demasiado conservadora en cuanto a los requisitos de compatibilidad hacia atrás, lo que resulta en un código hinchado e inmanejable. La IA siempre intenta conservar todas las funciones e interfaces antiguas para evitar romper el código existente. Sin embargo, este enfoque a menudo resulta contraproducente, ya que aumenta la complejidad y el costo de mantenimiento del código. A veces, eliminar funciones e interfaces antiguas puede simplificar el código y mejorar el rendimiento. Pero a la IA le resulta difícil hacer este equilibrio, ya que carece de comprensión de los requisitos del negocio y el comportamiento del usuario.

Si la IA considera que todas las exportaciones públicas deben conservarse, introduce estas interfaces de manera muy casual al crear nuevas funciones, pero en el mantenimiento posterior las trata como tesoros, temiendo eliminarlas por accidente. El resultado es un código cada vez más hinchado, con mayor complejidad y más errores.

Después de intentar guiar a la IA para que adoptara una estrategia de "permitir cambios disruptivos", la mejora fue notable. Esto indica que identificamos el problema correcto. Pero también surgió un nuevo problema: ¿cómo gestionar el riesgo de los cambios disruptivos?

Debemos hacer que la IA comprenda el principio de la navaja de Ockham: "No multipliques las entidades sin necesidad". Es decir, el código debe ser lo más simple posible, evitando complejidades y redundancias innecesarias. Solo cuando sea realmente necesario se deben introducir nuevas funciones e interfaces. Solo así se puede mantener la claridad y mantenibilidad del código.

Si la IA no separa las tareas de diseño y codificación, será difícil lograr esto.

## Conclusión

1. Enfatizar el no uso de la POO y cambiar a la programación orientada a procesos y funcional. Este es un atajo muy crítico que puede mejorar significativamente la calidad y mantenibilidad del código generado por la IA.
2. Guiar a la IA para que comprenda el principio de la navaja de Ockham, evitar la compatibilidad excesiva hacia atrás y reducir la hinchazón del código.

Todavía no sé cómo abordar otros aspectos, como el problema del andamiaje, la orientación arquitectónica, etc.