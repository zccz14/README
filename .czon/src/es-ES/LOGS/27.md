---
"title": "Estrategias de Traducción y Optimización con Multi-Agents de Generación Adversaria"
"summary": "Este artículo explora la aplicación de Multi-Agents en tareas de traducción. Mediante un modelo de generación adversaria (donde un modelo de traducción compite contra un modelo de revisión), se mejora significativamente la calidad de la traducción, resolviendo problemas de omisión de contenido, falta de coherencia y rigidez, aunque a costa de la eficiencia en tiempo y Tokens. Además, el artículo discute estrategias de optimización de memoria, como integrar múltiples Agentes en un único proceso para ahorrar memoria; en cuanto al control y restricciones, combina las ventajas de las restricciones blandas y duras, proponiendo el uso de un Agente Orchestrator para generar Scripts que permitan un control flexible y fiable; y compara la apertura del ecosistema de OpenCode frente a Claude, destacando la API amigable de OpenCode que facilita la integración."
"tags":
  - "Multi-Agents"
  - "Traducción por Generación Adversaria"
  - "Optimización de Memoria"
  - "Control y Restricciones"
  - "OpenCode"
  - "Claude"
  - "Calidad de Traducción"
  - "Colaboración entre Agentes"
"date": "2026-01-25"
---

Ahora es la tarde del domingo, 25 de enero de 2026.

**Multi-Agents: Traducción por Generación Adversaria**

Ayer completé la integración de traducción ligera de OpenCode para CZON, implementando un modelo básico de generación adversaria.

Esta tarea de traducción introduce dos roles: la tarea de traducción y la tarea de revisión. Ambas partes participan en una generación adversaria: el modelo de traducción es responsable de generar el resultado traducido, mientras que el modelo de revisión se encarga de evaluar si el resultado es aceptable. Si el modelo de revisión considera que la traducción no es satisfactoria, solicita al modelo de traducción que la regenere, y este proceso continúa hasta que se produce un resultado aceptable. (Actualmente, el número máximo de iteraciones es 10 para evitar bucles infinitos).

Este diseño de traducción, en comparación con la traducción LLM one-shot original, sacrifica la eficiencia en tiempo y Tokens. Sin embargo, tiene una ventaja clave: mejora drásticamente la calidad de la traducción, resolviendo los siguientes problemas:

1.  **Omisión de contenido:** Algunos modelos de traducción pueden omitir partes del texto original, resultando en una traducción incompleta. El modelo de revisión puede verificar que el resultado incluya todo el contenido original, asegurando la integridad.
2.  **Falta de coherencia en textos largos:** Al procesar artículos extensos, algunos modelos pueden producir inconsistencias entre el principio y el final. El modelo de revisión puede evaluar la coherencia general del texto traducido.
3.  **Rigidez y falta de naturalidad:** Algunas traducciones pueden sonar mecánicas o antinaturales. El modelo de revisión puede juzgar la fluidez del resultado, asegurando que se ajuste a las convenciones expresivas del idioma objetivo.

En términos de resultados, la prioridad de la calidad de la traducción es claramente superior a la eficiencia en Tokens y tiempo. Para escenarios como CZON, que requieren traducciones de alta calidad, el modelo de generación adversaria es una opción excelente.

**Optimización de Memoria en Multi-Agents**

No es viable iniciar un proceso separado para cada Agente, ya que cada proceso consume al menos unos 100 MB de memoria. Ejecutar múltiples Agentes simultáneamente podría agotar la memoria rápidamente. Un método mejor es integrar todos los Agentes para que se ejecuten dentro de un único proceso, ahorrando así recursos de memoria. OpenCode oficialmente separa el Servidor (Server) del Cliente (Client). Utiliza un proceso `serve` que escucha en un puerto (por defecto el 4096), y luego múltiples Clientes se conectan a este puerto para interactuar. Esto permite integrar todos los Agentes en el proceso del Servidor, mientras que los Clientes solo se encargan de enviar solicitudes y recibir respuestas.

De esta manera, deberíamos poder soportar el lanzamiento simultáneo de cientos de tareas de traducción sin que el sistema colapse por falta de memoria.

**Control y Restricciones en Multi-Agents**

En la industria existen dos enfoques principales: que un Agente controle a otro Agente, o utilizar un Script para controlar a los Agentes.

La diferencia radica en que el control Agente-a-Agente es una **restricción blanda**: el Agente puede decidir, según su propio criterio, si ejecuta o no la instrucción de otro Agente. En cambio, el control mediante Script es una **restricción dura**: el Agente debe seguir estrictamente las instrucciones del Script.

La ventaja de las restricciones blandas es la **flexibilidad**, su desventaja es la **falta de fiabilidad**. El problema de las restricciones blandas es común: se define un flujo de trabajo (*workflow*) para el Agente, pero a menudo este no lo sigue al pie de la letra, pudiendo incluso finalizar prematuramente, lo que resulta en resultados inesperados. El problema de las restricciones duras es que el Script puede no cubrir todos los escenarios posibles, dejando al Agente incapaz de manejar ciertas situaciones excepcionales.

Aunque parecen enfoques opuestos, en realidad se puede combinar lo mejor de ambos utilizando un **Agente Orchestrator** para generar un Script, y luego hacer que otros Agentes ejecuten sus tareas siguiendo ese Script. Esto proporciona tanto flexibilidad como fiabilidad. En etapas tempranas, incluso se pueden escribir Scripts manualmente para controlar el comportamiento de los Agentes. El control total es la máxima flexibilidad.

Por lo tanto, es crucial que la fricción para que un Script llame a un Agente sea mínima, idealmente reducida a una sola línea de código para realizar la programación, permitiendo así implementar una colaboración compleja entre múltiples Agentes.

En su [artículo](https://www.anthropic.com/engineering/multi-agent-research-system) sobre sistemas Multi-Agent, Anthropic menciona que es preferible que la salida de los sub-Agentes se escriba en el sistema de archivos, en lugar de devolverse al coordinador principal. Por lo tanto, podemos considerar que una llamada de Script a Agente no necesita devolver un resultado; basta con que el Agente escriba su resultado en el sistema de archivos, para que luego otros módulos lo lean desde allí.

Además, los Scripts pueden integrarse en lenguajes de programación comunes, como JavaScript. Utilizando una librería, se puede lograr que el Agente Orchestrator primero codifique el Script, y luego este Script invoque a otros Agentes para ejecutar tareas. Sin necesidad de un DSL (Lenguaje Específico del Dominio), superando sus limitaciones.

**Ecosistema Multi-Agents: OpenCode vs Claude Code**

El ecosistema de OpenCode es claramente más abierto que el de Claude. OpenCode permite invocar Agentes a través de una API HTTP (o SDK), consultar el estado de las Sesiones de los Agentes, obtener sus resultados de salida, etc. Esto nos permite integrar Agentes de OpenCode en nuestros sistemas de manera más conveniente, facilitando el trabajo colaborativo complejo entre múltiples Agentes. Claude, por el contrario, sigue el camino opuesto, intentando cerrar su ecosistema al permitir solo la invocación de sus Agentes a través de las interfaces proporcionadas por Anthropic, lo que limita la libertad del usuario.