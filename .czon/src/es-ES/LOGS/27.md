Es 25 de enero de 2026, domingo por la tarde.

**Multi-Agents: Traducción por Generación Adversaria**

Ayer completé la integración ligera de traducción OpenCode para CZON, implementando un modelo básico de generación adversaria.

Esta tarea de traducción introduce dos roles: la tarea de traducción y la tarea de revisión. Ambas partes participan en una generación adversaria. El modelo de traducción es responsable de generar el resultado de la traducción, mientras que el modelo de revisión se encarga de evaluar si el resultado de la traducción es aceptable. Si el modelo de revisión considera que el resultado no es aceptable, solicita al modelo de traducción que lo regenere, y este proceso continúa hasta que se genera un resultado aceptable. (Actualmente, el número máximo de iteraciones es 10 para evitar bucles infinitos).

Este diseño de traducción, en comparación con la traducción one-shot original de LLM, sacrifica la eficiencia en tiempo y en Tokens. Sin embargo, tiene una ventaja clave: mejora significativamente la calidad de la traducción, resolviendo los siguientes problemas:

1.  **Problema de omisión de contenido en la traducción:** Algunos modelos de traducción pueden omitir partes del texto original, resultando en una traducción incompleta. El modelo de revisión puede verificar si el resultado de la traducción incluye todo el contenido original, asegurando la integridad de la traducción.
2.  **Problema de incoherencia en la traducción de textos largos:** Algunos modelos de traducción pueden mostrar inconsistencias al procesar textos largos. El modelo de revisión puede verificar la coherencia del resultado de la traducción, asegurando que sea consistente en su conjunto.
3.  **Problema de rigidez y falta de naturalidad:** Algunos modelos de traducción pueden generar resultados que suenan rígidos o poco naturales. El modelo de revisión puede evaluar la fluidez del resultado de la traducción, asegurando que se ajuste a las convenciones expresivas del idioma de destino.

En cuanto a los resultados, la prioridad de la calidad de la traducción es claramente superior a la eficiencia en Tokens y en tiempo. Para escenarios como CZON, que requieren traducciones de alta calidad, el modelo de generación adversaria es una buena opción.

**Optimización de Memoria para Multi-Agents**

No es viable iniciar un proceso separado para cada Agente, ya que cada proceso consume al menos unos 100 MB de memoria. Ejecutar múltiples Agentes simultáneamente podría provocar una insuficiencia de memoria. Un método mejor es integrar todos los Agentes para que se ejecuten dentro de un único proceso, ahorrando así el consumo de memoria. OpenCode oficialmente separa el Servidor (Server) y el Cliente (Client). Puede utilizar un proceso `serve` que escuche en un puerto (por defecto el 4096), y luego múltiples Clientes se conectan a este puerto para interactuar. De esta manera, todos los Agentes pueden integrarse y ejecutarse dentro del proceso del Servidor, y los Clientes solo se encargan de enviar solicitudes y recibir respuestas.

De este modo, deberíamos poder soportar el inicio simultáneo de cientos de tareas de traducción sin que el sistema colapse por falta de memoria.

**Restricciones de Control en Multi-Agents**

En la industria existen dos enfoques: uno donde un Agente controla a otro Agente, y otro donde un Script controla a un Agente.

La diferencia radica en que el control de Agente a Agente es una **restricción blanda**; el Agente puede decidir, según su propio criterio, si ejecuta o no la instrucción de otro Agente. En cambio, el control por Script es una **restricción dura**; el Agente debe seguir estrictamente las instrucciones del Script.

La ventaja de la restricción blanda es la flexibilidad, su desventaja es la falta de fiabilidad. La ventaja de la restricción dura es la fiabilidad, su desventaja es la inflexibilidad.

Los problemas de la restricción blanda son comunes: se define un flujo de trabajo (workflow) en el Agente, pero a menudo este no sigue dicho flujo para ejecutar la tarea, incluso puede terminar prematuramente, lo que resulta en un resultado inesperado. El problema de la restricción dura es que el Script puede no cubrir todos los escenarios, haciendo que el Agente no pueda manejar ciertas situaciones excepcionales.

Aunque parecen incompatibles, en realidad se puede utilizar un **Agente Orquestador** para generar un Script, y luego hacer que otros Agentes ejecuten las tareas siguiendo ese Script. Esto combina las ventajas de ambos enfoques: flexibilidad y fiabilidad. En las primeras etapas, incluso se pueden escribir Scripts manualmente para controlar el comportamiento de los Agentes. El control total es la máxima flexibilidad.

Por lo tanto, es necesario que la fricción para que un Script llame a un Agente sea mínima, tan pequeña que una sola línea de código pueda implementar la programación, permitiendo así una compleja colaboración multi-Agente.

Anthropic, en su [artículo](https://www.anthropic.com/engineering/multi-agent-research-system) sobre Multi-Agent, menciona que es preferible que la salida de los sub-Agents se escriba en el sistema de archivos, en lugar de devolverse al coordinador principal. Por lo tanto, podemos considerar que cuando un Script llama a un Agente, no necesita que este devuelva un resultado; basta con que el Agente escriba el resultado en el sistema de archivos, y luego otros módulos lean el resultado desde allí.

En cuanto a los Scripts, estos pueden integrarse en lenguajes de uso común, como JS. Utilizando una librería, se puede lograr que el Agente Orquestador primero codifique el Script, y luego el Script invoque a otros Agentes para ejecutar las tareas. Sin necesidad de un DSL, superando a un DSL.

**Ecosistema Multi-Agents: OpenCode vs Claude Code**

El ecosistema de OpenCode es claramente más abierto que el de Claude. OpenCode permite invocar Agentes a través de una API HTTP (o SDK), consultar el estado de las Sesiones de los Agentes, obtener los resultados de salida de los Agentes, etc. Esto nos permite integrar más fácilmente los Agentes de OpenCode en nuestro sistema, logrando una compleja colaboración multi-Agente. Claude, por el contrario, va en dirección opuesta, intentando cerrar su ecosistema, permitiendo solo la invocación de sus Agentes a través de las interfaces proporcionadas por Anthropic, lo que limita la libertad del usuario.