Hoy es lunes, 12 de enero de 2026, por la mañana.

Me levanté temprano hoy. Al recordar la discusión de ayer con C1 sobre el diseño de AI Agent, siento que obtuve algunas ideas y necesito registrarlas.

Consultando el [antecedente](../INSIGHTS/1.md), diseñé una arquitectura de ingeniería de software con colaboración humano-máquina a nivel de módulo.

Estoy considerando cómo implementarla.

En pocas palabras, los puntos clave son:

1.  Es necesario gestionar el repositorio de código mediante el comando `git worktree` y proporcionar un script de configuración para cada Repo.
2.  Es necesario invocar el AI Agent (Claude Code, OpenCode, ...etc) a través de la CLI, pasarle un prompt e iniciar una sesión (Session).
3.  Es necesario poder recibir una notificación de finalización del AI Agent.
4.  Es necesario poder obtener el historial de conversación intermedio del AI Agent; de lo contrario, no se puede lograr transparencia. Consultando el problema de confianza controlable mencionado en [este documento](../INSIGHTS/2.md), necesitamos transparencia y controlabilidad durante el proceso.

Basándome en estas capacidades, puedo implementar un script automatizado para completar tareas de ingeniería de software a nivel de módulo.

Tomando Claude Code como ejemplo:

1.  Claude Code puede iniciar una nueva sesión directamente a través de la CLI pasándole un prompt.
2.  Cuando Claude Code imprime el resultado en stdout usando el parámetro `-p`, eso indica que ha finalizado.
3.  Claude Code proporciona la capacidad de pasar un ID de sesión, luego se puede encontrar el archivo correspondiente del historial de conversación en el directorio `.claude`, obteniendo así los mensajes históricos.

Dado esto, puedo escribir un script para gestionar estos trabajos.

Cada Sesión es independiente y limpia, y cada Sesión será asignada a un Agente para completarla.

Una instancia de Agente puede abstraerse como una interfaz, independientemente de si su base es Claude Code u otra.

El planificador (scheduler) asignará diferentes Agentes para completar las tareas según nuestro flujo de trabajo predeterminado.

¿Por qué basarse en Agent en lugar de la API de LLM? Porque el Agent maneja por nosotros la lógica subyacente de explorar el repositorio de código, invocar comandos del sistema operativo, gestionar el contexto y adaptarse a la API del LLM. Este es un sistema complejo, y creo que no necesitamos reinventar la rueda, a menos que no cumpla con los requisitos.

Planeo implementar primero una versión mínima para verificar si este enfoque es viable. Esperen los registros de progreso posteriores.