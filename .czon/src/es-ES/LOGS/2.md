---
"title": "Reflexiones sobre la práctica de programación con IA: Evitar la POO y la compatibilidad excesiva"
"summary": "Este artículo documenta la experiencia fallida del autor al usar IA para programar (Vibe Coding), descubriendo que el código orientado a objetos generado por la IA era de baja calidad y tenía una estructura caótica, lo que llevó a una explosión de deuda técnica. El autor analiza las causas, incluyendo la capacidad insuficiente de la IA para diseñar con el paradigma de POO, la falta de orientación arquitectónica y la compatibilidad excesiva hacia atrás. El artículo propone recomendaciones clave: evitar la programación orientada a objetos y cambiar hacia la programación orientada a procedimientos y funcional; guiar a la IA para que comprenda el principio de la navaja de Ockham y reduzca la hinchazón del código. Estas medidas tienen como objetivo mejorar la calidad y mantenibilidad del código generado por la IA."
"tags":
  - "Programación con IA"
  - "Programación orientada a objetos"
  - "Programación funcional"
  - "Calidad del código"
  - "Deuda técnica"
  - "Navaja de Ockham"
  - "Compatibilidad hacia atrás"
"date": "2026-01-07"
---

Hoy es 2026-01-07.

Un gran fracaso con Vibe Coding. El código que me escribió la IA era de tan baja calidad que resultaba completamente inutilizable. Me vi obligado a reescribir completamente el proyecto ZEN, utilizando la programación tradicional de la vieja escuela.

Usé la IA para generar código desde cero. Después de varias iteraciones, la calidad de la ingeniería comenzó a colapsar: las nuevas funciones no podían integrarse, los errores proliferaban, la estructura del código era caótica e incluso eliminar funcionalidades se volvió excepcionalmente difícil. Estos son síntomas típicos de una explosión de deuda técnica. Por lo tanto, intervine de manera decisiva y decidí reescribir todo el proyecto. Un punto clave fue descubrir que el código de POO escrito por la IA era especialmente malo. Por cada nueva función, la IA creaba una clase separada y luego perforaba un agujero en otras clases relacionadas para llamarla, lo que resultó en una gran cantidad de clases y métodos inútiles. Esto no es programación orientada a objetos, es claramente programación orientada a la lista de requisitos.

Analizando las causas, creo que:

1.  La capacidad de la IA para diseñar con el paradigma de programación orientada a objetos es insuficiente, probablemente debido a la falta de modelado de conceptos del dominio del negocio.
2.  La IA no distingue si está escribiendo código desechable o para mantenimiento a largo plazo. Carece de orientación arquitectónica y adopta una estrategia perezosa de "hacerlo todo de una vez".
3.  Falta un andamiaje (scaffolding) amigable para la IA. El proceso de arranque desde cero es bastante difícil para ella.
4.  La IA es demasiado conservadora en su enfoque hacia los requisitos de compatibilidad, lo que lleva a un código hinchado.

## El mito de la orientación a objetos

Creo que, actualmente, la IA no es adecuada para escribir código de programación orientada a objetos (POO). La POO requiere una comprensión profunda y capacidad de modelado del dominio del negocio, algo que la IA aún no puede manejar adecuadamente. Es más, resulta bastante irónico que incluso a los humanos no nos resulte fácil dominar esto. Por el contrario, la programación orientada a procedimientos y la programación funcional son más adecuadas para la IA, ya que se centran más en la transformación y el procesamiento de datos que en el estado y el comportamiento de los objetos.

Si usas orientación a objetos, necesitas que la IA domine también los patrones de diseño y la refactorización. Solo así podrá escribir código POO de alta calidad. Sin embargo, si usas programación orientada a procedimientos y funcional, la IA solo necesita centrarse en algoritmos y estructuras de datos para producir un código decente.

Entonces, ¿cuál es el beneficio de la orientación a objetos? ¿Encapsulación? ¿Herencia? ¿Polimorfismo? En la era de la IA, estos conceptos parecen menos cruciales, ya que surgieron para escribir menos código y facilitar la división del trabajo en equipo, cosas que a la IA no le importan. Por el contrario, la legibilidad, mantenibilidad y capacidad de prueba del código son clave. Y estas características se logran más fácilmente mediante la programación funcional y la orientada a procedimientos.

## Compatibilidad excesiva hacia atrás

La IA es demasiado conservadora con los requisitos de compatibilidad hacia atrás, lo que resulta en un código hinchado e inmanejable. La IA siempre intenta conservar todas las funciones e interfaces antiguas para evitar romper el código existente. Sin embargo, este enfoque a menudo resulta contraproducente, ya que aumenta la complejidad y el costo de mantenimiento del código. A veces, eliminar funciones e interfaces antiguas puede simplificar el código y mejorar el rendimiento. Pero a la IA le cuesta hacer este tipo de compensaciones porque carece de comprensión de los requisitos del negocio y el comportamiento del usuario.

Si la IA considera que todas las exportaciones públicas (`public export`) deben conservarse, introduce estas interfaces de manera muy casual al crear nuevas funciones, pero en el mantenimiento posterior las trata como tesoros, temiendo eliminarlas por accidente. El resultado es un código cada vez más hinchado, con mayor complejidad y más errores.

Después de intentar guiar a la IA para que adoptara una estrategia de "permitir cambios disruptivos", la mejora fue notable. Esto indica que identificamos el problema correcto. Pero también plantea una nueva cuestión: ¿cómo gestionar el riesgo de los cambios disruptivos?

Es imperativo que la IA comprenda el principio de la navaja de Ockham: *"No multipliques las entidades sin necesidad"*.
En otras palabras, el código debe ser lo más simple posible, evitando complejidades y redundancias innecesarias. Solo se deben introducir nuevas funciones e interfaces cuando sea estrictamente necesario. Solo así se puede mantener la claridad y mantenibilidad del código.

Si la IA no separa las tareas de diseño y codificación, le resultará muy difícil lograr esto.

## Conclusión

1.  **Enfatizar el no uso de POO**, cambiando hacia la programación orientada a procedimientos y funcional. Este es un atajo muy importante que puede mejorar drásticamente la calidad y mantenibilidad del código generado por la IA.
2.  **Guiar a la IA para que comprenda el principio de la navaja de Ockham**, evitando la compatibilidad excesiva hacia atrás y reduciendo la hinchazón del código.

Todavía no tengo claro cómo abordar otros aspectos, como el problema del andamiaje (scaffolding) o la orientación arquitectónica.