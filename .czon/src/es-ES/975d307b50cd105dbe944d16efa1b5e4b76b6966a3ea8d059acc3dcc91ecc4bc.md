---
title: Experiencias de fracaso y reescritura en programación con IA
summary: El autor reescribió el proyecto ZEN tras descubrir que el código orientado a objetos generado por IA era de baja calidad y generaba una explosión de deuda técnica, optando por programación procedural y funcional, y recomendando evitar la compatibilidad excesiva hacia atrás para mejorar la calidad del código.
tags:
  - Programación con IA
  - Programación orientada a objetos
  - Programación funcional
  - Deuda técnica
  - Calidad del código
  - Navaja de Ockham
  - Compatibilidad hacia atrás
inferred_date: 2025-01-07
inferred_lang: es-ES
---

Hoy es 2025-01-07.

Vibe Coding ha sido un gran fracaso. El código que la IA me escribió era de tan baja calidad que resultaba completamente inutilizable. Me vi obligado a reescribir por completo el proyecto ZEN, implementándolo mediante programación tradicional "a la antigua usanza".

Utilicé IA para generar código desde cero. Después de varias iteraciones, la calidad del proyecto comenzó a colapsar: las nuevas funcionalidades no podían integrarse, los errores proliferaban, la estructura del código era caótica e incluso eliminar funciones se volvió excepcionalmente difícil. Estos son síntomas típicos de una explosión de deuda técnica. Por ello, intervine de manera decisiva y decidí reescribir todo el proyecto. Un hallazgo clave fue que el código orientado a objetos escrito por la IA era especialmente deficiente: por cada nueva funcionalidad, creaba una clase separada y luego "perforaba" otras clases relacionadas para invocarla, generando una gran cantidad de clases y métodos inútiles. Esto no es programación orientada a objetos, sino programación orientada a listas de requisitos.

Las razones, en mi opinión, son las siguientes:

1. La IA tiene una capacidad insuficiente para diseñar bajo el paradigma de programación orientada a objetos, posiblemente debido a la falta de modelado de conceptos del dominio del negocio.
2. La IA no distingue si está escribiendo código desechable o código para mantenimiento a largo plazo. Al carecer de una guía arquitectónica, adopta una estrategia perezosa de "hacerlo todo de una vez".
3. Falta un andamiaje (scaffolding) amigable para la IA, lo que dificulta el proceso de arranque desde cero.
4. La IA es excesivamente conservadora en cuanto a los requisitos de compatibilidad, lo que provoca que el código se vuelva inflado.

## El mito de la programación orientada a objetos

Creo que, actualmente, la IA no es adecuada para escribir código orientado a objetos. Este paradigma exige una comprensión profunda y capacidad de modelado del dominio del negocio, algo que la IA aún no puede lograr. Curiosamente, incluso para los humanos esto no es tarea fácil. Por el contrario, la programación procedural y funcional es más adecuada para la IA, ya que se centra más en la transformación y procesamiento de datos que en el estado y comportamiento de los objetos.

Si utilizas programación orientada a objetos, necesitas que la IA domine tanto los patrones de diseño como la refactorización para producir código de alta calidad. En cambio, con programación procedural y funcional, la IA solo necesita centrarse en algoritmos y estructuras de datos para escribir código aceptable.

Entonces, ¿cuáles son los beneficios de la orientación a objetos? ¿Encapsulación? ¿Herencia? ¿Polimorfismo? En la era de la IA, estos conceptos parecen menos relevantes, ya que surgieron para reducir la cantidad de código escrito y facilitar la colaboración en equipo, aspectos que a la IA le son indiferentes. Por el contrario, la legibilidad, mantenibilidad y capacidad de prueba del código son clave. Y estas características se logran más fácilmente mediante programación funcional y procedural.

## Compatibilidad excesiva hacia atrás

La IA es demasiado conservadora en cuanto a los requisitos de compatibilidad hacia atrás, lo que resulta en un código inflado. La IA siempre intenta conservar todas las funcionalidades e interfaces antiguas para evitar romper el código existente. Sin embargo, este enfoque suele ser contraproducente, ya que aumenta la complejidad y el costo de mantenimiento del código. A veces, eliminar funcionalidades e interfaces antiguas puede simplificar el código y mejorar el rendimiento. Pero a la IA le resulta difícil tomar este tipo de decisiones, ya que carece de comprensión sobre las necesidades del negocio y el comportamiento de los usuarios.

Si la IA considera que todas las exportaciones públicas deben conservarse, introduce estas interfaces de manera indiscriminada al crear nuevas funcionalidades, pero luego las trata como tesoros durante el mantenimiento, temiendo eliminarlas por error. El resultado es un código cada vez más inflado, con mayor complejidad y más errores.

Tras intentar guiar a la IA para que adoptara una estrategia de "permitir cambios disruptivos", la mejora fue notable. Esto indica que identificamos el problema correcto. Sin embargo, surgió una nueva cuestión: ¿cómo gestionar el riesgo de los cambios disruptivos?

Es crucial que la IA comprenda el principio de la **navaja de Ockham**: "No multipliques las entidades sin necesidad". Es decir, el código debe ser lo más simple posible, evitando complejidades y redundancias innecesarias. Solo se deben introducir nuevas funcionalidades e interfaces cuando sea estrictamente necesario. Así se mantiene la claridad y mantenibilidad del código.

Si la IA no separa las tareas de diseño y codificación, le resultará difícil aplicar este principio.

## Conclusión

1. **Enfatizar el no uso de POO**, optando por programación procedural y funcional. Este es un atajo crucial que puede mejorar significativamente la calidad y mantenibilidad del código generado por la IA.
2. **Guiar a la IA para que comprenda el principio de la navaja de Ockham**, evitando la compatibilidad excesiva hacia atrás y reduciendo la inflación del código.

Todavía no tengo claro cómo abordar otros aspectos, como el problema del andamiaje (scaffolding) o la guía arquitectónica.