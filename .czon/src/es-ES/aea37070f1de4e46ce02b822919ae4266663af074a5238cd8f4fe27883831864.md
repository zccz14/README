---
"title": "Estrategias de Traducción y Optimización con Multi-Agents mediante Generación Adversaria"
"summary": "Este artículo explora la aplicación de Multi-Agents en tareas de traducción, mejorando significativamente la calidad de traducción mediante un modelo de generación adversaria (modelo de traducción vs modelo de revisión), resolviendo problemas de omisión de contenido, incoherencia y rigidez, aunque sacrificando eficiencia en tiempo y Tokens. Además, discute estrategias de optimización de memoria, como integrar Agents en un solo proceso para ahorrar memoria; en cuanto al control de restricciones, combina las ventajas de restricciones blandas y duras, proponiendo usar un Orchestrator Agent para generar Scripts que permitan un control flexible y confiable; y compara la apertura del ecosistema de OpenCode vs Claude, destacando la API amigable de OpenCode que facilita la integración."
"tags":
  - "Multi-Agents"
  - "Traducción por Generación Adversaria"
  - "Optimización de Memoria"
  - "Control de Restricciones"
  - "OpenCode"
  - "Claude"
  - "Calidad de Traducción"
  - "Colaboración entre Agents"
"date": "2026-01-25"
---

Es 25 de enero de 2026, domingo por la tarde.

**Multi-Agents: Traducción por Generación Adversaria**

Ayer completé la integración ligera de traducción con OpenCode para CZON, implementando un modelo básico de generación adversaria.

Esta tarea de traducción introduce dos tareas: traducción y revisión. Ambas realizan generación adversaria: el modelo de traducción se encarga de generar resultados de traducción, mientras que el modelo de revisión evalúa si los resultados son aceptables. Si el modelo de revisión considera que los resultados no son aceptables, solicita al modelo de traducción que regenere hasta obtener resultados satisfactorios. (Actualmente hay un máximo de 10 iteraciones para evitar bucles infinitos).

Este diseño de traducción, en comparación con la traducción one-shot original de LLM, sacrifica eficiencia en tiempo y Tokens. Sin embargo, tiene una ventaja clave: mejora significativamente la calidad de traducción, resolviendo los siguientes problemas:

1. **Omisión de contenido**: Algunos modelos de traducción omiten ciertos contenidos del texto original, resultando en traducciones incompletas. El modelo de revisión puede verificar que la traducción incluya todo el contenido original, asegurando integridad.
2. **Incoherencia en textos largos**: Al procesar textos extensos, algunos modelos pueden producir inconsistencias. El modelo de revisión evalúa la coherencia de la traducción, asegurando consistencia general.
3. **Rigidez y falta de naturalidad**: Algunas traducciones pueden resultar rígidas o poco naturales. El modelo de revisión evalúa la fluidez, asegurando que la traducción se ajuste a las convenciones expresivas del idioma objetivo.

En términos de resultados, la prioridad de calidad de traducción claramente supera la eficiencia en Tokens y tiempo. Para escenarios como CZON que requieren traducciones de alta calidad, el modelo de generación adversaria es una opción adecuada.

**Optimización de Memoria en Multi-Agents**

No es viable iniciar un proceso separado para cada Agent, ya que cada proceso consume al menos 100MB de memoria. Ejecutar múltiples Agents simultáneamente podría causar insuficiencia de memoria. Un enfoque mejor es integrar todos los Agents en un solo proceso, reduciendo el consumo de memoria. OpenCode oficialmente separa Server y Client: utiliza un proceso serve que escucha en un puerto (por defecto 4096), y múltiples Clients se conectan a este puerto para interactuar. Esto permite integrar todos los Agents en un solo proceso Server, mientras que los Clients solo envían solicitudes y reciben respuestas.

De esta manera, deberíamos poder manejar cientos de tareas de traducción simultáneas sin colapsar por falta de memoria.

**Control de Restricciones en Multi-Agents**

Existen dos enfoques en la industria: hacer que un Agent controle a otro, o usar Scripts para controlar Agents.

La diferencia radica en que el control Agent-Agent es una restricción blanda: el Agent puede decidir si ejecuta o no las instrucciones de otro Agent según su propio criterio. En cambio, el control mediante Scripts es una restricción dura: el Agent debe seguir estrictamente las instrucciones del Script.

Las restricciones blandas ofrecen flexibilidad pero carecen de fiabilidad; las restricciones duras son fiables pero carecen de flexibilidad.

Los problemas con restricciones blandas son comunes: aunque se definen workflows en los Agents, estos frecuentemente no los siguen, llegando incluso a terminar prematuramente, produciendo resultados inesperados. Los problemas con restricciones duras son que los Scripts pueden no cubrir todos los escenarios, impidiendo que los Agents manejen ciertas situaciones especiales.

Aunque parecen incompatibles, en realidad se puede usar un Orchestrator Agent para generar Scripts, y luego hacer que otros Agents ejecuten tareas según estos Scripts. Esto combina las ventajas de ambos enfoques: flexibilidad y fiabilidad. En etapas iniciales, incluso se pueden escribir Scripts manualmente para controlar el comportamiento de los Agents. El control total es la máxima flexibilidad.

Por lo tanto, es crucial minimizar la fricción al llamar Agents desde Scripts, hasta el punto de que una sola línea de código pueda implementar la programación, permitiendo así una colaboración compleja entre múltiples Agents.

Anthropic, en su [artículo sobre Multi-Agent](https://www.anthropic.com/engineering/multi-agent-research-system), menciona que es preferible que la salida de los sub-Agents se escriba en el sistema de archivos en lugar de devolverse al coordinador principal. Por lo tanto, podemos considerar que llamar a un Agent desde un Script no necesita devolver resultados; solo requiere que el Agent escriba resultados en el sistema de archivos, para que otros módulos los lean posteriormente.

Además, los Scripts pueden integrarse en lenguajes comunes, como JS, utilizando una librería que permita al Orchestrator Agent primero codificar el Script, y luego que el Script llame a otros Agents para ejecutar tareas. Sin necesidad de DSL, superando a los DSL.

**Ecosistema Multi-Agents: OpenCode vs Claude Code**

El ecosistema de OpenCode es claramente más abierto que el de Claude. OpenCode permite llamar a Agents mediante API HTTP (o SDK), ver el estado de las sesiones de Agents, obtener resultados de salida, etc. Esto facilita la integración de Agents de OpenCode en nuestros sistemas, permitiendo una colaboración compleja entre múltiples Agents. En contraste, Claude sigue el camino opuesto, buscando cerrar su ecosistema, permitiendo solo llamar a Agents de Claude a través de interfaces proporcionadas por Anthropic, lo que limita la libertad del usuario.