---
"title": "全谱分析法：信息的最优变现方法"
"summary": "本文提出全谱分析法（FSA），一种基于凯利准则优化的投资交易策略框架。文章首先分析了传统凯利公式在投资应用中的局限性，如缺乏杠杆和做空\
  考虑、清算时机问题等。然后，FSA通过定义结局空间、计算最优杠杆和复合收益率，构建了一个系统化的交易决策模型。文章详细阐述了FSA的数学原理，包括期望收益\
  率、复合收益率的计算，以及使用牛顿迭代法求解最优杠杆的算法。此外，还介绍了历史回测方法（如毛利率GPM计算）、实盘交易模块的考虑，以及应对黑天鹅事件的措施\
  。FSA的核心优势在于能够利用不完美的概率信息，通过优化杠杆决策来最大化长期收益，降低了对信息质量的高要求。"
"tags":
  - "全谱分析法"
  - "凯利公式"
  - "投资策略"
  - "杠杆优化"
  - "复合收益率"
  - "风险管理"
  - "算法交易"
  - "黑天鹅事件"
"date": "2025-08-10"
---

# 全谱分析法：信息的最优变现方法

2025-08-10

## 背景

**如何最大化资产的增长率？**

1956 年，J.L. Kelly 发表了《A New Interpretation of Information Rate》（信息率的新诠释）。论文讨论了一个赌徒如何利用已知信息，最大化资产的复合增长率。它提出了一种概率化的方法来指导赌博投注策略。但是这篇论文运用于实际投资活动中，有若干问题：

1. 它没有运用借款杠杆和做空，使得论文的结论停留在 0~1 的实际杠杆范围内。
2. 它假设赌徒押注的是某个事件符号，下一次发生就获得赔付，否则输光赌注。但交易者只能押注做多/做空，而多空对应的涨跌事件，在不同时间窗口下，呈现不同的结果和不同的收益率。
3. 清算时机：凯利假设赌局的结束清算不由赌徒的意志决定。但交易者可以随时决定退出或者继续持仓。
4. 冗余的贝叶斯方法，假设事件的发展与之前的先验概率和条件概率有关。移除贝叶斯方法并不影响其导出的数学本质。增大了难度，直接使用论文公式的难度大，实际使用需要简化。

我们将沿用凯利论文中的概率化方法，探索一个可以适用于投资交易领域的实用策略。

## 全谱分析法：Full-Spectrum Analysis, FSA

### 结局空间、最优杠杆和最优收益率

假设实施某个交易策略，最终会有若干个不同的结局事件，设结局空间为 $X$。$X$非空（实际场景中至少存在 2 个结局）。

额外做一些假设：

1. 确定性收益：每一种结局事件对应了一个明确的收益率。设结局 $i$ 的收益率为 $R_i$。
   1. ✅ 不同收益率的事件，应当视为不同的结局事件，例如盈利 1% 和盈利 2% 是不同的。
   1. ❌ 将收益率明显不同的盈利事件装到同一个结局中，这违反确定性收益。
1. 确定性概率：设结局 $i \in X$发生的概率为 $P_i$，（$0 \le P_i \le 1$）。
   1. ✅ 每个结局的概率都需要被确定性地评估。
   1. ❌ 认为某个结局发生的可能是八成以上：80%～ 100%，这违反确定性概率。
1. 互斥性：不可能同时发生 2 个结局。
   1. ✅ 要设计完全不可能同时发生的结局事件。
   1. ❌ 结局事件中存在交集，例如“持仓 20 分钟”和“跌 20%”事件可能同时发生，违反互斥性。
1. 完备性：所有结局发生的概率之和为 100%，不存在预设结局之外的结局，即$\sum_{i \in X} P_i = 1$。
   1. ✅ 要考虑到所有的可能发生的结局。
   1. ❌ 结局事件中只定义了“涨 20% 以上”、“跌 20% 以上”，并没有定义“涨跌在 -20%～ 20% 之间”，违反完备性。
1. 杠杆效应：收益率遵循杠杆效应，即如果使用 $k$倍杠杆，结局 $i$发生时，收益率为 $k \cdot R_i$，即资产会变为原先的 $1 + k \cdot R_i$倍。
1. ✅ 流动性足够大的投资品都符合这种特性。
1. ❌ 当持仓额过高后，由于流动性原因，会产生市场冲击成本，收益不再符合线性关系。

对于结局空间 $X$，可以计算其 **期望收益率 Expected Earning Yield**：
$$E(X) = \sum_{i \in X} P_i R_i$$

期望收益率的思想较为直观，也方便计算。期望收益率的问题是：

1. 衍生的决策极端，要么空仓要么满仓，无法控制破产风险，如果期望收益率为正，它就会倾向于无限放大杠杆，来博取更高的收益率，即便高杠杆可以带来破产。
2. 没有考虑复利效应。只考虑了单次投资的收益情况，没有考虑市场是可以重复投资的。不符合实际投资管理的情况。

**复合收益率 Compound Earning Yield**，是指重复多次独立的交易后，均摊到单次交易上的收益率：

$$C(X, k) = (\prod_{i \in X} (1 + k \cdot R_i)^{P_i}) - 1$$

**最优收益率 Optimal Earning Yield**，是不同杠杆下，复合收益率的最大值：

$$O(X) = \max_k C(X, k)$$

为了不破产归零，应当满足对于所有结局，$1 + k \cdot R_i >0$，可以导出一个 k 的基本可行域 $K$：

上界：

$$\max k = \max(0, \min_{R_i < 0} {-\frac{1}{R_i}})$$

下界：

$$\min k = \min(0, \max_{R_i > 0} {-\frac{1}{R_i}})$$

以及一个总是可行的解 $k = 0$，

$$K = (\min k, \max k) \cup \{ 0 \}$$

最优杠杆，就是在可行域 $K$内，使得复合收益率最大 $C(X, k)$的 $k$。

$$k_o = \argmax_k C(X, k)$$

任何时刻，都可以计算账户中的实际杠杆： $k = \frac{头寸规模}{账户净值}$，也可以评估最优杠杆：$k_o$。
所有交易策略，最终都会对应一个实际杠杆。做出确定性的交易决策，等价于决定 $k$的取值。而最优杠杆就对应了理想的持仓。

于是得到了一个交易框架：

1. 设计结局空间 $X$。
2. 不断评估不同结局的概率 $P$。
3. 计算实际杠杆 $k$ 和最优杠杆 $k_O$。
4. 控制实际杠杆接近最优杠杆。

> **特殊点**
>
> 平凡点$C(X, 0) = 0$，即“不参与就不会有盈亏”。
> 当我们没有仓位时，等效于我们决定令 $k = 0$。对于任何的品种，无论有无仓位，我们每时每刻都在做决定。
> 做空即 $k < 0$ 的情况；如果 $|k| > 1$，意味着需要额外加杠杆。

### 求解最优化

回顾问题，已知结局空间 $X$，概率分布 $P_i$，收益率 $E_i$，可行域 $[L, R]$，求使得收益率最大的杠杆率 $k \in [L, R]$：

对复合收益率移项整理，两边取对数后（保持了单调性），可以得到：

$$\ln (1 + C(X, k)) = \sum_{i \in X} P_i \ln (1 + k \cdot R_i)$$

令

$$G(k) = \ln(1 + C(X, k)) = \sum_{i \in X} P_i \ln (1 + k R_i)$$

根据最优杠杆的定义：

$$k_o = \argmax_k C(X, k)$$

由于 $f(x) = \ln(1+x)$ 单调递增：

$$k_o = \argmax_k C(X, k) = \argmax_k G(k)$$

对 $G(k)$ 求一阶导数、二阶导数：

$$G'(k) = \sum_{i \in X} \frac{P_i R_i}{1 + k R_i} $$

$$G''(k) = \sum\_{i \in X} -\frac{P_i R_i^2}{(1 + k R_i)^2} $$

二阶导数中每一项都是非正的，所以 $G''(k) \le 0$。当且仅当 $P_i R_i \equiv 0$时，$G''(k) = 0$，而这种情况下，$G(k) \equiv 0$，没有任何收益，没有实际意义。其他情况下，$G''(k) < 0$。这意味着 $G(k)$ 是一个严格凹函数，$G'(k)$严格单调递减。 $G(k)$ 有且只有一个极大值点，并且此极大值点就是最大值点。

如下图所示，无论是多少项的 $G(k)$，其曲线都是凹函数。

![凯利公式-曲线示意图](image-1.png)

$G(k)$的极大值点就是其一阶导数的零点：

$$G'(k) = \sum_{i \in X} \frac{P_i R_i}{1 + k R_i} = 0$$

如果整理此方程，可以转化为一个关于 k 的多项式方程。
如果存在 $N$个不同的 $R_i$的取值，则上述多项式方程的最高次为 $N-1$。
根据阿贝尔-鲁菲尼定理，五次及更高次的多项式，没有一般的求根公式。

常见的凯利公式，就是 $N=2$ 的特殊情况：设胜率 $p$，赔率 $b$。

| 结局 | 概率  | 收益率 |
| ---- | ----- | ------ |
| 胜   | $p$   | $b$    |
| 负   | $1-p$ | $-1$   |

代入得到方程：

$$G'(k) = \frac{pb}{1+kb} + \frac{-(1-p)}{1 -k} = 0$$

整理后可得

$$k = \frac{p(b+1)-1}{b}$$

即证凯利公式。

对于交易场景，可能出现的不同收益率的结局可能有无数种，因此，只能求数值解。

作为单变量的严格凹函数，使用牛顿迭代法求解是黄金选择。
从不动点 $$G(0) = 0$$开始迭代是个不错的选择，严格凹函数从任何点开始迭代都会收敛到一样的结果。

#### 牛顿法超出可行域的情形

潜在的问题是，牛顿迭代法得到的迭代点，可能会超出问题的可行域。
用一个最小化的例子来说明这个情形：

$$p_1 = 0.9, r_1 = 0.5, p_2 = 0.1, r_2 = -1$$

得到

$$G(k) = 0.9 \times \ln(1+0.5k) + 0.1 \times \ln(1 - k)$$

![G(k) 函数图像](image-2.png)

计算可得可行域 $K = (-2, 1)$，有解析最优杠杆 $k_o = 0.7$，
但是使用牛顿迭代法时，第一个迭代点

$$G(0) - \frac{G'(0)}{G''(0)} = \frac{14}{13} > 1$$

![G‘(k) 及牛顿迭代法演示](image-3.png)

第一个迭代点就超出了可行域，超出了导数的定义域，再进行迭代就无意义了。这说明朴素的牛顿迭代法自身无法处理超出可行域的情形。

解决方法是，使用牛顿迭代法计算迭代点后，需要额外判断其是否在可行域内。如果在，就迭代至此，如果不在，根据其方向，取可行域边界与当前点之间的一个点作为下一个迭代点。

#### 算法伪代码

算法 $\text{resolve}(G, L, R, \epsilon = 10^{-9}, N = 100, \alpha = 0.9)$

1. 初始化$k \gets 0$
2. 根据回报率 $r_i$，计算基本可行域 $K$
3. 裁剪可行域 $L \gets \max(L, \min K), R \gets \min(R, \max K)$
4. 最大循环 $N$ 次：

   1. 计算下一个点$k' \gets k - \frac{G'(k)}{G''(k)}$
   2. 如果 $k'$不属于 $K$

      1. 如果 $k' \ge R$，取 $k' \gets \alpha R + (1-\alpha)k$
      2. 如果 $k' \le L$，取 $k' \gets \alpha L + (1 - \alpha) k$

   3. 如果差额小于精度阈值 $| k' - k | < \epsilon$，跳出循环。
   4. 更新$k \gets k'$

5. 返回 $k$

#### 代码实现

编程的角度来说，更合适的抽象是，设结局集合中每个结局有两个属性，回报率 r、权重 w。这个结局空间可以被遍历，那么算法可以写作：

```ts
/**
 * 根据凯利准则，计算最佳杠杆 k 和期望收益 e。
 *
 * @param R - 回报率向量
 * @param W - 权重向量
 * @param lower - 最小杠杆限制
 * @param upper - 最大杠杆限制
 * @param eps - 收敛精度
 * @param max_iter - 最大迭代次数
 * @param alpha - 收敛加速因子
 * @returns 一个对象，包含最佳杠杆 k 和期望收益 e
 */
export function resolve_k(
  R: number[],
  W: number[],
  lower = -Infinity,
  upper = Infinity,
  eps = 1e-9,
  max_iter = 100,
  alpha = 0.9
) {
  const n = R.length;
  if (n !== W.length)
    throw new Error(
      "Returning and Probability vectors must have the same length"
    );

  // 计算基本可行域 K, 使得 1 + k * r > 0
  let minK = NaN;
  let maxK = NaN;
  for (let i = 0; i < n; i++) {
    const r = R[i];
    if (r === 0) continue;
    const k = -1 / r; // 临界值
    if (r > 0) minK = isNaN(minK) ? k : Math.max(minK, k);
    if (r < 0) maxK = isNaN(maxK) ? k : Math.min(maxK, k);
  }
  if (isNaN(minK)) minK = 0; // 如果没有正的 R，则 minK 取 0
  if (isNaN(maxK)) maxK = 0; // 如果没有负的 R，则 maxK 取 0
  lower = Math.max(lower, minK);
  upper = Math.min(upper, maxK);

  let sum_w = 0;
  for (let i = 0; i < n; i++) {
    const w = W[i];
    if (w < 0) throw new Error(`Weight[${i}] = ${w} must be non-negative`);
    sum_w += w;
  }
  if (sum_w === 0) throw new Error("Sum of weights must be greater than zero");

  let k = 0;
  let it;
  for (it = 0; it < max_iter; it++) {
    let acc_g1 = 0;
    let acc_g2 = 0;
    for (let i = 0; i < n; i++) {
      const r = R[i];
      const w = W[i];
      acc_g1 += (w * r) / (1 + k * r);
      acc_g2 += (w * r * r) / (1 + k * r) ** 2;
    }
    const delta_k = acc_g1 / acc_g2;
    if (!(Math.abs(delta_k) > eps)) break;
    let next_k = k + delta_k;
    if (next_k <= lower) {
      next_k = lower * alpha + k * (1 - alpha);
    } else if (next_k >= upper) {
      next_k = upper * alpha + k * (1 - alpha);
    }

    k = next_k;
  }

  const lne =
    R.reduce((acc, r, i) => acc + W[i] * Math.log(1 + k * r), 0) / sum_w;
  const e = Math.exp(lne) - 1;

  return { k, e, it, sum_w, lne, upper, lower };
}
```

### 其他的数学性质

#### 不限可行域时，期望收益率为正时，最优收益率为正

证明：
由于 $f(x) = \ln(1+x)$ 与 $x$符号相同，所以$C(X, k) $与 $G(k)$的符号是相同的，
考虑 $G(k)$在 $k = 0$ 处的导数：$G'(0) = \sum_{i \in X} P_i R_i $，实际上就是期望收益率 $E(X)$。
对于一个无穷小量 $\Delta k$，根据导数定义，$G(\Delta k) = G(0) + G'(0) \cdot \Delta k = E(X) \cdot \Delta k$

如果 $E(X) > 0$，则存在 $\Delta k > 0$使得 $G(\Delta k) > 0$，即 $C(X, \Delta k) >0$，而最优收益率
$$O(X) = \max C(X, k) \ge C(X, \Delta k) > 0$$

证毕。

除此之外，可证如下表结论：

| 期望收益率 | 最优杠杆 | 最优收益率 |
| ---------- | -------- | ---------- |
| 正         | 正       | 正         |
| 0          | 0        | 0          |
| 负         | 负       | 正         |

## FSA 的历史回测方法

### 毛利率：Gross Profit Margin, GPM

根据交易框架所述，每个时刻都可以计算实际杠杆 $k$ 和最优杠杆 $k_O$，并控制实际杠杆趋同于最优杠杆。

这里我们 默认采用单利 的回测方式，因为复利模型会影响后面的成本估计，复利模型会产生非常大的成交额变动，导致抵达策略容量后，对市场产生额外的冲击成本，导致实际能成交的量或者成本严重偏离模型值，造成回测失真。在真实场景中，复利操作往往是人为控制的，即主观地调整初始净值或者交易倍数来产生一种“单利”和“复利”之间的“部分复利”的方案。

关键约束： $K_t$仅依赖 $0, 1, ..., t$时刻的已知信息，不存在未来函数。$K_t$会影响 $t+1$时刻的持仓量。

进行历史回测，首先我们需要知道价格 $P_t$，以及对应的计划净持仓量 $V_t$。

微观来看，在 $t$时刻，知晓价格 $P_t$ 的同时，会知晓净值 $E_t$，净持仓量 $H_t$。

先考虑一下边界情况：$V_0 = 0, E_0 = 0$。

经过一个可以忽略不计的分析用时后，得到计划净持仓量 $V_t$。

需要调仓的交易量为 $V_t - H_t$

此后，直至 $t + 1$时刻，会立即开始下单

流动性充裕的假设下，会在 $P_{t+1}$的价格完全成交，使$H_{t+1} = V_t$。
设 $c$为基于成交额的成本，则成本为 $c \cdot |V_t - H_t| \cdot P_{t+1}$。
并且，净持仓$H_t$会受到价格变动的影响，产生盈亏 $H_t (P_{t+1} - P_t)$。

综上所述，在 $t + 1$时刻：

$$H_{t+1} = V_t$$
$$E_{t+1} = E_t + H_t (P_{t+1} - P_t) - c \cdot |H_{t+1} - H_t| \cdot P_{t+1}$$

单利模式下，持仓量和交易成本都与初始净值成正比。

持仓后，价格变化带来的总利润（Profit and Loss, PnL）：

$$\text{PnL} = \sum_t H_t \cdot (P_{t + 1} - P_t)$$

总成交额：

$$\text{Turnover} = \sum_t |H_{t+1} - H_t| \cdot P_{t+1}$$

可以估计出模型能打平的最大交易成本，即毛利率(Gross Profit Margin, GPM)：

$$\text{GPM}  = \frac{\text{PnL}}{\text{Turnover}}$$

之后，实盘交易中，低于此 GPM 的实际成本率即为有利可图。而这个 GPM 暗示了模型的容量，如果这个 GPM 比较大，意味着实盘时可以使用更大的交易滑点，提高实际成交量。

模型的任务是最大化 GPM，而交易模块的任务是实现这个 GPM 约束下的盈利。具体来说，在之后的实盘中，交易模块的任务是，在不超过 GPM 的情况下，尽量多地完成成交额。交易模块无法规避交易所自带的手续费率，手续费率可能会受多种因素影响，例如 VIP，返佣，Maker/Taker 等不同的情况会影响实际的手续费率。如果模型的 GPM 大于某交易所的手续费率，可以认为该模型很难在该交易所中实现盈利，需要改进模型。如果交易模块认为当前任务无法达成，可以选择降低成交额或者不成交，保持在零头寸。

最终的利润可以认为是：成交额 \* (GPM - 实际成本)。如果提高初始净值，将增大成交额，会使得实际成本率不断逼近 GPM，直至无利可图。但是从公式来看，应当存在一个利润的最优化问题。这个最大利润对应的初始净值即为交易模型的容量。具体的评估，需要再深入研究成交额和成本的关系。

### 持仓分辨率

实际交易中，产品具有最小成交量的步长 (volume_step)，头寸仅能以步长的整数倍成交。
因此，给定一个浮点数目标头寸，并不能 100%跟踪这个目标头寸。因此，我们需要将这个目标头寸取整到可交易的头寸上。

持仓分辨率, Holding Resolution，是一个正整数。

如果对于最优杠杆 $k_O$采取单利法，然后通过分辨率映射，会得到目标仓位 $V$。代入回测框架以后可以计算出 MER。

- 如果持仓分辨率 = 1，意味着策略只会交易底仓。即目标仓位的取值为 -1, 0, 1。
- 如果持仓分辨率 = 2，意味着策略开始需要分仓。目标仓位的取值为 -2, -1, 0, 1, 2。
- 如果持仓分辨率 = ∞，意味着策略可以以任何精度调整仓位。但这不符合实际情况。

持仓分辨率越低，在后续的小资金实盘时，需要的基础资金越少，但是利用的信息就模糊。

理论上，持仓分辨率会影响成交额，分辨率越低，成交额越低（本来需要调仓的情况变成不需要调仓）。持仓分辨率对收益的影响尚不明确。经验上，如果 MER 足够高，并且对分辨率不敏感，意味着可以直接进行实盘。

## 实盘交易模块

实盘交易模块需要在 MER 约束下，实现盈利。

但开仓与平仓的约束不一致，开仓时可以容忍目标成交额未完全成交，但是平仓时不能容忍这件事。因此平仓时，约束较为严格，最坏情况下要以市价单进行成交，会造成较高的手续费和滑点。

假设市价单成本率为 $c$，则开仓时需要以 $2 \times \text{MER} - c$ 的成本率进行开仓，才是安全的。

例如 MER = 0.02%，市价单成本为 0.03%，则开仓成本至多为 0.01%。

## 关于结局空间

### 黑天鹅的应对措施

黑天鹅是指极不可能发生，实际上却又发生的事件。

1. 无法通过任何模型估计黑天鹅发生的概率，任何对黑天鹅的估计都是徒劳的，其概率是不可知的。
2. 黑天鹅事件一旦发生，将产生极大的损失。
   为此，设计任何的结局空间，都需要防御黑天鹅事件的发生。
3. 黑天鹅出现时，一定会产生 -100% 的收益率，即全额亏损。
4. 黑天鹅无法被已知样本，用任何概率分布进行拟合。
   因此，为黑天鹅事件虚构一个伪概率 是必要的。

假设我们从已有的样本中，为我们设定的结局空间 $X$赋予了一个概率 $P_i$。

需要人为地，加入两个对称的黑天鹅事件：$P_b^- = 0.0013, r_b = -1, P_b^+ = 0.0013, r_b = 1$。其中 0.0013 是正态分布中 $3\sigma$之外的概率，大约是 770 个样本中会出现 1 个。 对黑天鹅事件的概率赋值越大，策略越趋于保守。

设计对称的黑天鹅事件，是为了不影响期望收益率，防止改变最优杠杆的符号，避免出现原本是 0 杠杆的情况下，反而判断需要做空的局面。

而原概率则需要被缩小到 $1 - P_b^- - P_b^+ = 0.9974$倍，以保证整个新的结局空间的完备性。

加入黑天鹅事件，会使得可行域缩小，最优杠杆率被严格限制在 $(-1, 1)$内，仍然可以做空，但是无法被加额外的杠杆。黑天鹅事件的加入，可以有效防止滥用杠杆的问题。

```ts
export function withBlackSwan(R: number[], W: number[], Pb = 0.0013) {
  const sum_w = W.reduce((acc, cur) => acc + cur, 0);
  const w_b = (Pb * sum_w) / (1 - 2 * Pb);
  return {
    R: R.concat([1, -1]),
    W: W.concat([w_b, w_b]),
  };
}
```

## 总结

对于给定的结局空间 $X$而言，$R_i$是确定的，只要估计出结局空间中的概率分布 $P_i$，就可以得到确定性的最优杠杆 $k_O$。只要你认为交易系统应当是一致的，它们的概率就应该是重复的，在这个情形下，全谱分析法无损地利用了不完美的信息，因此没有任何理由不去严格遵循这个最优杠杆。

有一些交易系统，想要求出最高概率发生的结局，并根据这个结局制定交易计划。这是一种极大似然法。这种方法的风险在于，如果似然函数比较平坦，那么选取任何其一的解释，都是不够准确的。这种策略会显得时而有效时而无效。而全谱分析法并不需要去遵循最高概率结局，它可以计算出不同结局下的收益，选取最优的头寸。它可以捕捉到细微的信息，并做出最优决策。因此，全谱分析法极大降低了变现信息的质量门槛。

至于如何设计结局空间并估计概率分布，属于需要被变现的信息本身的内容，且听下回分解。
