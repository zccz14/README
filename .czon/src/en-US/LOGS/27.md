---
"title": "Multi-Agent Adversarial Generation Translation and Optimization Strategies"
"summary": "This article explores the application of Multi-Agents in translation tasks. By employing an adversarial generation model (where a translation model and a review model compete), translation quality is significantly improved, addressing issues such as content omission, incoherence, and unnatural phrasing, albeit at the cost of time and token efficiency. The article also discusses memory optimization strategies, such as integrating Agents into a single process to save memory. Regarding control constraints, it combines the advantages of soft and hard constraints, proposing the use of an Orchestrator Agent to generate Scripts for flexible and reliable control. Furthermore, it compares the ecosystem openness of OpenCode and Claude, emphasizing OpenCode's API-friendliness for easier integration."
"tags":
  - "Multi-Agents"
  - "Adversarial Generation Translation"
  - "Memory Optimization"
  - "Control Constraints"
  - "OpenCode"
  - "Claude"
  - "Translation Quality"
  - "Agent Collaboration"
"date": "2026-01-25"
---

It is now the afternoon of Sunday, January 25, 2026.

**Multi-Agents: Adversarial Generation Translation**

Yesterday, the lightweight OpenCode translation integration for CZON was completed, implementing a basic adversarial generation model.

This translation task introduces a translation task and a review task. The two engage in adversarial generation: the translation model is responsible for generating translation results, while the review model is responsible for assessing whether the translation results are acceptable. If the review model deems the translation result unacceptable, it instructs the translation model to regenerate until an acceptable result is produced. (Currently, the maximum iteration is set to 10 to prevent infinite loops.)

Compared to the original one-shot LLM translation, this design sacrifices time and token efficiency. However, it offers a key advantage: it significantly improves translation quality by addressing the following issues:

1.  **Content omission in translation:** Some translation models may omit certain parts of the original text, leading to incomplete translations. The review model can check if the translation includes all original content, ensuring completeness.
2.  **Incoherence in long-text translation:** Some translation models may produce inconsistent results when handling long articles. The review model can check the coherence of the translation, ensuring overall consistency.
3.  **Unnatural and awkward phrasing:** Some translation models may generate translations that sound stiff or unnatural. The review model can evaluate the fluency of the translation, ensuring it conforms to the expressive norms of the target language.

From the results, it's clear that translation quality takes priority over token efficiency and time efficiency. For scenarios like CZON that require high-quality translation, the adversarial generation model is a suitable choice.

**Multi-Agents Memory Optimization**

We cannot launch a separate process for each Agent, as each process consumes at least around 100MB of memory. Running multiple Agents simultaneously would lead to insufficient memory. A better approach is to integrate all Agents to run within a single process, saving memory overhead. OpenCode officially separates Server and Client. It can use a serve process to listen on a port (default 4096), with multiple Clients connecting to this port for interaction. This allows all Agents to be integrated into a single Server process, with Clients only responsible for sending requests and receiving responses.

This way, we should be able to support launching hundreds of translation tasks simultaneously without crashing due to memory exhaustion.

**Multi-Agents Control Constraints**

The industry has two main approaches: one involves having an Agent control other Agents, and the other uses a Script to control Agents.

The difference lies in the fact that Agent-controlled-Agent is a soft constraint; the Agent can decide whether to execute another Agent's instructions based on its own judgment. Script-controlled-Agent is a hard constraint; the Agent must strictly follow the Script's instructions.

The advantage of soft constraints is flexibility; the disadvantage is unreliability. The advantage of hard constraints is reliability; the disadvantage is inflexibility.

Problems with soft constraints are common. For instance, a workflow might be defined within an Agent, but the Agent often doesn't follow it, sometimes even exiting prematurely, leading to results that don't meet expectations. The problem with hard constraints is that the Script might not cover all scenarios, leaving the Agent unable to handle certain special cases.

While these two seem incompatible, in reality, an Orchestrator Agent can be used to generate a Script, which other Agents then follow. This combines the advantages of both: flexibility and reliability. In the early stages, Scripts can even be written manually to control Agent behavior. Complete control is the ultimate flexibility.

Therefore, the friction for a Script to call an Agent must be minimal—small enough to be achievable with a single line of code—enabling the implementation of complex multi-Agent collaborative work.

In their [article](https://www.anthropic.com/engineering/multi-agent-research-system) on Multi-Agent systems, Anthropic mentions that sub-Agent outputs are best written to the file system rather than returned to the main coordinator. Therefore, we can consider that a Script calling an Agent does not need to return a result; it only needs the Agent to write the result to the file system, which can then be read by other modules.

Furthermore, Scripts can be integrated into common languages, such as JavaScript. Using a library, an Orchestrator Agent can first encode a Script, which then calls other Agents to execute tasks. This approach, without a DSL, surpasses using a DSL.

**Multi-Agents Ecosystem: OpenCode vs Claude Code**

The OpenCode ecosystem is clearly more open than Claude's. OpenCode allows calling Agents via HTTP API (or SDK), viewing Agent Session status, retrieving Agent output, etc. This makes it more convenient for us to integrate OpenCode Agents into our systems to achieve complex multi-Agent collaboration. Claude, on the other hand, takes the opposite approach, striving to create a closed ecosystem, only allowing Claude Agents to be called through interfaces provided by Anthropic, which limits user freedom.