---
"title": "Reflections on AI Programming Practices: Avoiding OOP and Over-Compatibility"
"summary": "This article documents the author's failed experience with AI-assisted programming (Vibe Coding), where AI-generated object-oriented code was of poor quality and structurally chaotic, leading to an explosion of technical debt. The author analyzes the reasons, including AI's insufficient design capability for OOP paradigms, lack of architectural guidance, and excessive backward compatibility. Key recommendations are proposed: avoid object-oriented programming in favor of procedural and functional programming; guide AI to understand Occam's Razor to reduce code bloat. These measures aim to improve the quality and maintainability of AI-generated code."
"tags":
  - "AI Programming"
  - "Object-Oriented Programming"
  - "Functional Programming"
  - "Code Quality"
  - "Technical Debt"
  - "Occam's Razor"
  - "Backward Compatibility"
"date": "2026-01-07"
---

Today is 2026-01-07.

A major failure with Vibe Coding—the code generated by AI was of such poor quality that it was completely unusable. I had no choice but to completely rewrite the ZEN project, resorting to traditional, old-school programming methods.

I used AI to generate code from scratch. After several iterations, the project's quality began to collapse: new features couldn't be integrated, bugs proliferated endlessly, the code structure became chaotic, and even deleting functionality became exceptionally difficult. These are classic symptoms of technical debt explosion. Consequently, I intervened decisively and decided to rewrite the entire project. A key insight was that the OOP code written by AI was particularly poor in quality. For every new feature, AI would create a separate class and then "punch holes" in other related classes to call it, resulting in a large number of useless classes and methods. This wasn't object-oriented programming; it was more like "requirement-checklist-oriented programming."

The reasons, I believe, are as follows:

1. AI has insufficient design capability for object-oriented programming paradigms, likely due to a lack of modeling for business domain concepts.
2. AI doesn't know whether it's writing throwaway code or code for long-term maintenance. Without architectural guidance, it adopts a lazy, "hack-it-together" strategy.
3. There's a lack of an AI-friendly scaffolding, making the bootstrapping process from scratch quite challenging for AI.
4. AI is overly conservative about compatibility requirements, leading to code bloat.

## The OOP Myth

I believe AI is currently not well-suited for writing object-oriented code. OOP requires a deep understanding and modeling capability of the business domain, which AI currently cannot handle. Ironically, even humans often struggle with this. In contrast, procedural and functional programming are more suitable for AI, as they focus more on data transformation and processing rather than object state and behavior.

If you use OOP, you need AI to be proficient in design patterns and refactoring to produce high-quality object-oriented code. However, with procedural and functional programming, AI only needs to focus on algorithms and data structures to write decent code.

So, what are the benefits of OOP? Encapsulation? Inheritance? Polymorphism? In the age of AI, these seem less critical, as they were designed to reduce code duplication and facilitate team collaboration—concerns that AI doesn't share. Instead, code readability, maintainability, and testability are key. These qualities are more easily achieved through functional and procedural programming.

## Excessive Backward Compatibility

AI is overly conservative about backward compatibility, leading to bloated code. AI always tries to preserve all old features and interfaces to avoid breaking existing code. However, this approach often backfires by increasing code complexity and maintenance costs. Sometimes, deleting old features and interfaces can simplify the code and improve performance. But AI struggles with this trade-off because it lacks an understanding of business requirements and user behavior.

If AI treats every public export as something that must be preserved, it introduces these interfaces casually when creating new features but later treats these "junk interfaces" like precious treasures, afraid to delete them. The result is increasingly bloated code, rising complexity, and more bugs.

After I tried guiding AI to adopt a "allow breaking changes" strategy, the situation improved significantly. This indicates we've identified the core issue. However, it also raises a new question: how do we manage the risks associated with breaking changes?

AI must understand **Occam's Razor**: "Entities should not be multiplied without necessity." In other words, code should be as simple as possible, avoiding unnecessary complexity and redundancy. New features and interfaces should only be introduced when absolutely necessary. This is the only way to maintain code clarity and maintainability.

If AI doesn't separate design and coding tasks, achieving this becomes very difficult.

## Conclusion

1. **Emphasize avoiding OOP** and shift toward procedural and functional programming. This is a crucial shortcut that can significantly improve the quality and maintainability of AI-generated code.
2. **Guide AI to understand Occam's Razor**, avoid excessive backward compatibility, and reduce code bloat.

Other issues, such as scaffolding and architectural guidance, remain unresolved for now.