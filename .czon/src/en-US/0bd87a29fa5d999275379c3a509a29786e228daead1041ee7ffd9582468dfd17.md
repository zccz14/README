---
"title": "Reflections on AI Programming Failures and Project Rewrites"
"summary": "This document describes the severe issues the author encountered on January 7, 2026, while using AI (Vibe Coding) to generate code. These issues included poor code quality, exploding technical debt, chaotic Object-Oriented Programming (OOP) implementations, and code bloat caused by excessive backward compatibility. The author analyzes AI's shortcomings in OOP design, architectural guidance, and compatibility management. It suggests shifting towards procedural and functional programming to improve code quality and emphasizes applying Occam's Razor to simplify code. The document also discusses challenges with AI in scaffolding and architectural guidance and proposes directions for improvement."
"tags":
  - "AI Programming"
  - "Object-Oriented Programming"
  - "Code Quality"
  - "Technical Debt"
  - "Functional Programming"
  - "Occam's Razor"
  - "Backward Compatibility"
  - "Vibe Coding"
"inferred_date": "2026-01-07"
"inferred_lang": "zh-Hans"
---

Today is 2026-01-07.

Using Vibe Coding was a massive failure. The code quality generated by the AI was so poor that it was completely unusable. I was forced to completely rewrite the ZEN project, switching to traditional, time-tested programming methods.

I used AI to generate code from scratch. After multiple iterations, the project's quality began to collapse. New features couldn't be integrated, bugs proliferated endlessly, the code structure became chaotic, and even deleting functionality became exceptionally difficult. These are classic symptoms of exploding technical debt. Consequently, I decisively intervened and decided to rewrite the entire project. A key discovery was that the OOP code written by the AI was particularly poor in quality. For every new feature, it would create a separate class and then "poke a hole" in other related classes to call it, resulting in a large number of useless classes and methods. This wasn't Object-Oriented Programming; it was more like "Requirement Checklist-Oriented Programming."

The reasons, I believe, are:

1.  AI has insufficient capability in designing for the Object-Oriented Programming paradigm, likely due to a lack of modeling for business domain concepts.
2.  AI doesn't know whether it's writing throwaway code or code for long-term maintenance. It lacks architectural guidance and resorts to a lazy, "hack it together" strategy.
3.  There is a lack of an AI-friendly scaffolding. The process of bootstrapping from scratch is quite challenging for AI.
4.  AI is overly conservative in its approach to compatibility requirements, leading to code bloat.

## The OOP Misconception

I believe AI is currently not well-suited for writing Object-Oriented Programming code. OOP requires a deep understanding and modeling capability of the business domain, which AI currently cannot handle. Ironically, even humans often struggle with this. Conversely, procedural and functional programming are more suitable for AI because they focus more on data transformation and processing rather than object state and behavior.

If you use OOP, you need the AI to be proficient in design patterns and refactoring simultaneously to produce high-quality OOP code. However, if you use procedural and functional programming, the AI only needs to focus on algorithms and data structures to write decent code.

So, what are the benefits of OOP? Encapsulation? Inheritance? Polymorphism? In the age of AI, these seem less critical because they were created to reduce code writing and facilitate team collaborationâ€”concerns that are irrelevant to AI. Instead, code readability, maintainability, and testability are key. These qualities are more easily achieved through functional and procedural programming.

## Excessive Backward Compatibility

AI is overly conservative regarding backward compatibility requirements, resulting in severely bloated code. AI always tries to preserve all old functionality and interfaces to prevent breaking existing code. However, this approach often backfires because it increases code complexity and maintenance costs. Sometimes, deleting old features and interfaces can actually simplify the code and improve performance. But AI struggles to make this trade-off because it lacks an understanding of business requirements and user behavior.

If AI treats all `public exports` as sacred and must be preserved, it introduces these interfaces casually when creating new features. Yet, during subsequent maintenance, it treats these garbage interfaces like precious treasures, afraid to delete them by accident. The result is increasingly bloated code, rising complexity, and more bugs.

After I tried guiding the AI to adopt an "allow breaking changes" strategy, the situation improved significantly. This indicates we identified the core problem. However, it also raises a new question: how do we manage the risk of breaking changes?

We must make AI understand **Occam's Razor**: "Entities should not be multiplied without necessity."
In other words, code should be as simple as possible, avoiding unnecessary complexity and redundancy. New features and interfaces should only be introduced when genuinely needed. This is the only way to maintain code clarity and maintainability.

If AI doesn't separate design and coding tasks, achieving this is very difficult.

## Conclusion

1.  **Emphasize avoiding OOP and shift towards procedural and functional programming.** This is a crucial shortcut that can significantly improve the quality and maintainability of AI-generated code.
2.  **Guide AI to understand Occam's Razor**, avoid excessive backward compatibility, and reduce code bloat.

I haven't figured out solutions for other issues yet, such as the scaffolding problem and architectural guidance.