---
"title": "Reflexiones sobre el fracaso de la programación con IA y la reescritura de un proyecto"
"summary": "El documento describe los graves problemas encontrados por el autor el 7 de enero de 2026 al usar IA (Vibe Coding) para generar código, incluyendo mala calidad del código, explosión de deuda técnica, implementación caótica de la programación orientada a objetos (POO) y código hinchado debido a una excesiva compatibilidad con versiones anteriores. El autor analiza las deficiencias de la IA en el diseño de POO, la orientación arquitectónica y la gestión de la compatibilidad, sugiere cambiar a programación procedural y funcional para mejorar la calidad del código, y enfatiza la aplicación del principio de la navaja de Ockham para simplificar el código. El documento también discute los desafíos de la IA en andamiajes y orientación arquitectónica, y propone direcciones de mejora."
"tags":
  - "Programación con IA"
  - "Programación Orientada a Objetos"
  - "Calidad del Código"
  - "Deuda Técnica"
  - "Programación Funcional"
  - "Navaja de Ockham"
  - "Compatibilidad con Versiones Anteriores"
  - "Vibe Coding"
"inferred_date": "2026-01-07"
"inferred_lang": "es-ES"
---

Hoy es 7 de enero de 2026.

Uso de Vibe Coding: un gran fracaso. La calidad del código que me escribió la IA es demasiado pobre, completamente inutilizable. Me vi obligado a reescribir completamente el proyecto ZEN, implementándolo con la programación tradicional de la vieja escuela.

Usé la IA para generar código desde cero. Después de varias iteraciones, la calidad de la ingeniería comenzó a colapsar: las nuevas funcionalidades no podían integrarse, los errores proliferaban, la estructura del código era caótica e incluso eliminar funciones se volvió excepcionalmente difícil. Estos son síntomas típicos de una explosión de deuda técnica. Por lo tanto, intervine decididamente y decidí reescribir todo el proyecto. Un punto clave que descubrí es que la calidad del código POO escrito por la IA es particularmente mala. Cada vez que había una nueva funcionalidad, me creaba una clase separada y luego perforaba un agujero en otras clases relacionadas para llamarla, resultando en una gran cantidad de clases y métodos inútiles. Esto no es programación orientada a objetos, es claramente programación orientada a la lista de requisitos.

Las razones, en mi opinión, son:

1. La capacidad de diseño de la IA para el paradigma de programación orientada a objetos es insuficiente, probablemente debido a la falta de modelado de conceptos del dominio del negocio.
2. La IA no distingue si está haciendo código desechable o código para mantenimiento a largo plazo. Carece de orientación arquitectónica y adopta una estrategia perezosa de "hacerlo todo de una vez".
3. Falta un andamiaje (scaffolding) amigable para la IA. El proceso de arranque desde cero es bastante difícil para la IA.
4. La IA es demasiado conservadora en su interpretación de los requisitos de compatibilidad, lo que lleva a un código hinchado.

## El mito de la Programación Orientada a Objetos

Creo que, actualmente, la IA no es adecuada para escribir código de programación orientada a objetos. La POO requiere una comprensión profunda y capacidad de modelado del dominio del negocio, algo que la IA aún no puede manejar adecuadamente. Es más, resulta bastante ridículo que incluso a los humanos no nos resulte fácil dominar esto. Por el contrario, la programación procedural y funcional es más adecuada para la IA, ya que se centra más en la transformación y procesamiento de datos que en el estado y comportamiento de los objetos.

Si usas programación orientada a objetos, necesitas que la IA domine simultáneamente los patrones de diseño y la refactorización. Solo así podrá escribir código POO de alta calidad. Sin embargo, si usas programación procedural y funcional, la IA solo necesita centrarse en algoritmos y estructuras de datos para producir un código decente.

Entonces, ¿cuál es el beneficio de la POO? ¿Encapsulación? ¿Herencia? ¿Polimorfismo? En la era de la IA, estos conceptos parecen menos importantes, ya que surgieron para escribir menos código y facilitar la división del trabajo en equipo, cosas que a la IA le son indiferentes. Por el contrario, la legibilidad, mantenibilidad y capacidad de prueba del código son clave. Y estas características se logran más fácilmente mediante la programación funcional y procedural.

## Compatibilidad excesiva con versiones anteriores

La IA es demasiado conservadora con los requisitos de compatibilidad con versiones anteriores, lo que resulta en un código excesivamente hinchado. La IA siempre intenta conservar todas las funciones e interfaces antiguas para evitar romper el código existente. Sin embargo, este enfoque a menudo resulta contraproducente, ya que aumenta la complejidad y el costo de mantenimiento del código. A veces, eliminar funciones e interfaces antiguas puede simplificar el código y mejorar el rendimiento. Pero a la IA le cuesta hacer este tipo de compensaciones porque carece de comprensión de los requisitos del negocio y el comportamiento del usuario.

Si la IA considera que todas las exportaciones públicas (`public export`) deben conservarse, introduce estas interfaces de manera muy laxa al crear nuevas funcionalidades, pero en el mantenimiento posterior las trata como tesoros, temiendo eliminarlas por accidente. El resultado es un código cada vez más hinchado, con mayor complejidad y más errores.

Después de intentar guiar a la IA para que adoptara una estrategia de "permitir cambios disruptivos", la mejora fue notable. Esto indica que identificamos el problema correcto. Pero también plantea una nueva cuestión: ¿cómo gestionar el riesgo de los cambios disruptivos?

Es imperativo que la IA comprenda el **principio de la navaja de Ockham**: *"Las entidades no deben multiplicarse sin necesidad"* (o "En igualdad de condiciones, la explicación más sencilla suele ser la correcta").
En otras palabras, el código debe ser lo más simple posible, evitando complejidades y redundancias innecesarias. Solo se deben introducir nuevas funciones e interfaces cuando sea estrictamente necesario. Así se mantiene la claridad y mantenibilidad del código.

Si la IA no separa las tareas de diseño y codificación, le resultará muy difícil lograr esto.

## Conclusión

1.  **Enfatizar el no uso de POO y cambiar a programación procedural y funcional.** Este es un atajo muy crucial que puede mejorar significativamente la calidad y mantenibilidad del código generado por la IA.
2.  **Guiar a la IA para que comprenda el principio de la navaja de Ockham**, evitando una compatibilidad excesiva con versiones anteriores y reduciendo la hinchazón del código.

Todavía no tengo claro cómo abordar otros aspectos, como el problema del andamiaje (scaffolding), la orientación arquitectónica, etc.